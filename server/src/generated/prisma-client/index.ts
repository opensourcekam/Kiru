// Code generated by Prisma (prisma@1.32.0-beta). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  feedback: (where?: FeedbackWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  geo: (where?: GeoWhereInput) => Promise<boolean>;
  influencer: (where?: InfluencerWhereInput) => Promise<boolean>;
  instagram: (where?: InstagramWhereInput) => Promise<boolean>;
  interest: (where?: InterestWhereInput) => Promise<boolean>;
  jobs: (where?: JobsWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  mediaKit: (where?: MediaKitWhereInput) => Promise<boolean>;
  social: (where?: SocialWhereInput) => Promise<boolean>;
  twitter: (where?: TwitterWhereInput) => Promise<boolean>;
  youtube: (where?: YoutubeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  feedback: (where: FeedbackWhereUniqueInput) => FeedbackPromise;
  feedbacks: (args?: {
    where?: FeedbackWhereInput;
    orderBy?: FeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Feedback>;
  feedbacksConnection: (args?: {
    where?: FeedbackWhereInput;
    orderBy?: FeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FeedbackConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  geo: (where: GeoWhereUniqueInput) => GeoPromise;
  geos: (args?: {
    where?: GeoWhereInput;
    orderBy?: GeoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Geo>;
  geosConnection: (args?: {
    where?: GeoWhereInput;
    orderBy?: GeoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GeoConnectionPromise;
  influencer: (where: InfluencerWhereUniqueInput) => InfluencerPromise;
  influencers: (args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Influencer>;
  influencersConnection: (args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InfluencerConnectionPromise;
  instagram: (where: InstagramWhereUniqueInput) => InstagramPromise;
  instagrams: (args?: {
    where?: InstagramWhereInput;
    orderBy?: InstagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Instagram>;
  instagramsConnection: (args?: {
    where?: InstagramWhereInput;
    orderBy?: InstagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InstagramConnectionPromise;
  interest: (where: InterestWhereUniqueInput) => InterestPromise;
  interests: (args?: {
    where?: InterestWhereInput;
    orderBy?: InterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Interest>;
  interestsConnection: (args?: {
    where?: InterestWhereInput;
    orderBy?: InterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InterestConnectionPromise;
  jobs: (where: JobsWhereUniqueInput) => JobsPromise;
  jobses: (args?: {
    where?: JobsWhereInput;
    orderBy?: JobsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Jobs>;
  jobsesConnection: (args?: {
    where?: JobsWhereInput;
    orderBy?: JobsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobsConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  mediaKit: (where: MediaKitWhereUniqueInput) => MediaKitPromise;
  mediaKits: (args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MediaKit>;
  mediaKitsConnection: (args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MediaKitConnectionPromise;
  social: (where: SocialWhereUniqueInput) => SocialPromise;
  socials: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Social>;
  socialsConnection: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialConnectionPromise;
  twitter: (where: TwitterWhereUniqueInput) => TwitterPromise;
  twitters: (args?: {
    where?: TwitterWhereInput;
    orderBy?: TwitterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Twitter>;
  twittersConnection: (args?: {
    where?: TwitterWhereInput;
    orderBy?: TwitterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TwitterConnectionPromise;
  youtube: (where: YoutubeWhereUniqueInput) => YoutubePromise;
  youtubes: (args?: {
    where?: YoutubeWhereInput;
    orderBy?: YoutubeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Youtube>;
  youtubesConnection: (args?: {
    where?: YoutubeWhereInput;
    orderBy?: YoutubeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => YoutubeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createFeedback: (data: FeedbackCreateInput) => FeedbackPromise;
  updateFeedback: (args: {
    data: FeedbackUpdateInput;
    where: FeedbackWhereUniqueInput;
  }) => FeedbackPromise;
  updateManyFeedbacks: (args: {
    data: FeedbackUpdateManyMutationInput;
    where?: FeedbackWhereInput;
  }) => BatchPayloadPromise;
  upsertFeedback: (args: {
    where: FeedbackWhereUniqueInput;
    create: FeedbackCreateInput;
    update: FeedbackUpdateInput;
  }) => FeedbackPromise;
  deleteFeedback: (where: FeedbackWhereUniqueInput) => FeedbackPromise;
  deleteManyFeedbacks: (where?: FeedbackWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createGeo: (data: GeoCreateInput) => GeoPromise;
  updateGeo: (args: {
    data: GeoUpdateInput;
    where: GeoWhereUniqueInput;
  }) => GeoPromise;
  updateManyGeos: (args: {
    data: GeoUpdateManyMutationInput;
    where?: GeoWhereInput;
  }) => BatchPayloadPromise;
  upsertGeo: (args: {
    where: GeoWhereUniqueInput;
    create: GeoCreateInput;
    update: GeoUpdateInput;
  }) => GeoPromise;
  deleteGeo: (where: GeoWhereUniqueInput) => GeoPromise;
  deleteManyGeos: (where?: GeoWhereInput) => BatchPayloadPromise;
  createInfluencer: (data: InfluencerCreateInput) => InfluencerPromise;
  updateInfluencer: (args: {
    data: InfluencerUpdateInput;
    where: InfluencerWhereUniqueInput;
  }) => InfluencerPromise;
  updateManyInfluencers: (args: {
    data: InfluencerUpdateManyMutationInput;
    where?: InfluencerWhereInput;
  }) => BatchPayloadPromise;
  upsertInfluencer: (args: {
    where: InfluencerWhereUniqueInput;
    create: InfluencerCreateInput;
    update: InfluencerUpdateInput;
  }) => InfluencerPromise;
  deleteInfluencer: (where: InfluencerWhereUniqueInput) => InfluencerPromise;
  deleteManyInfluencers: (where?: InfluencerWhereInput) => BatchPayloadPromise;
  createInstagram: (data: InstagramCreateInput) => InstagramPromise;
  updateInstagram: (args: {
    data: InstagramUpdateInput;
    where: InstagramWhereUniqueInput;
  }) => InstagramPromise;
  updateManyInstagrams: (args: {
    data: InstagramUpdateManyMutationInput;
    where?: InstagramWhereInput;
  }) => BatchPayloadPromise;
  upsertInstagram: (args: {
    where: InstagramWhereUniqueInput;
    create: InstagramCreateInput;
    update: InstagramUpdateInput;
  }) => InstagramPromise;
  deleteInstagram: (where: InstagramWhereUniqueInput) => InstagramPromise;
  deleteManyInstagrams: (where?: InstagramWhereInput) => BatchPayloadPromise;
  createInterest: (data: InterestCreateInput) => InterestPromise;
  updateInterest: (args: {
    data: InterestUpdateInput;
    where: InterestWhereUniqueInput;
  }) => InterestPromise;
  updateManyInterests: (args: {
    data: InterestUpdateManyMutationInput;
    where?: InterestWhereInput;
  }) => BatchPayloadPromise;
  upsertInterest: (args: {
    where: InterestWhereUniqueInput;
    create: InterestCreateInput;
    update: InterestUpdateInput;
  }) => InterestPromise;
  deleteInterest: (where: InterestWhereUniqueInput) => InterestPromise;
  deleteManyInterests: (where?: InterestWhereInput) => BatchPayloadPromise;
  createJobs: (data: JobsCreateInput) => JobsPromise;
  updateJobs: (args: {
    data: JobsUpdateInput;
    where: JobsWhereUniqueInput;
  }) => JobsPromise;
  updateManyJobses: (args: {
    data: JobsUpdateManyMutationInput;
    where?: JobsWhereInput;
  }) => BatchPayloadPromise;
  upsertJobs: (args: {
    where: JobsWhereUniqueInput;
    create: JobsCreateInput;
    update: JobsUpdateInput;
  }) => JobsPromise;
  deleteJobs: (where: JobsWhereUniqueInput) => JobsPromise;
  deleteManyJobses: (where?: JobsWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createMediaKit: (data: MediaKitCreateInput) => MediaKitPromise;
  updateMediaKit: (args: {
    data: MediaKitUpdateInput;
    where: MediaKitWhereUniqueInput;
  }) => MediaKitPromise;
  updateManyMediaKits: (args: {
    data: MediaKitUpdateManyMutationInput;
    where?: MediaKitWhereInput;
  }) => BatchPayloadPromise;
  upsertMediaKit: (args: {
    where: MediaKitWhereUniqueInput;
    create: MediaKitCreateInput;
    update: MediaKitUpdateInput;
  }) => MediaKitPromise;
  deleteMediaKit: (where: MediaKitWhereUniqueInput) => MediaKitPromise;
  deleteManyMediaKits: (where?: MediaKitWhereInput) => BatchPayloadPromise;
  createSocial: (data: SocialCreateInput) => SocialPromise;
  updateSocial: (args: {
    data: SocialUpdateInput;
    where: SocialWhereUniqueInput;
  }) => SocialPromise;
  updateManySocials: (args: {
    data: SocialUpdateManyMutationInput;
    where?: SocialWhereInput;
  }) => BatchPayloadPromise;
  upsertSocial: (args: {
    where: SocialWhereUniqueInput;
    create: SocialCreateInput;
    update: SocialUpdateInput;
  }) => SocialPromise;
  deleteSocial: (where: SocialWhereUniqueInput) => SocialPromise;
  deleteManySocials: (where?: SocialWhereInput) => BatchPayloadPromise;
  createTwitter: (data: TwitterCreateInput) => TwitterPromise;
  updateTwitter: (args: {
    data: TwitterUpdateInput;
    where: TwitterWhereUniqueInput;
  }) => TwitterPromise;
  updateManyTwitters: (args: {
    data: TwitterUpdateManyMutationInput;
    where?: TwitterWhereInput;
  }) => BatchPayloadPromise;
  upsertTwitter: (args: {
    where: TwitterWhereUniqueInput;
    create: TwitterCreateInput;
    update: TwitterUpdateInput;
  }) => TwitterPromise;
  deleteTwitter: (where: TwitterWhereUniqueInput) => TwitterPromise;
  deleteManyTwitters: (where?: TwitterWhereInput) => BatchPayloadPromise;
  createYoutube: (data: YoutubeCreateInput) => YoutubePromise;
  updateYoutube: (args: {
    data: YoutubeUpdateInput;
    where: YoutubeWhereUniqueInput;
  }) => YoutubePromise;
  updateManyYoutubes: (args: {
    data: YoutubeUpdateManyMutationInput;
    where?: YoutubeWhereInput;
  }) => BatchPayloadPromise;
  upsertYoutube: (args: {
    where: YoutubeWhereUniqueInput;
    create: YoutubeCreateInput;
    update: YoutubeUpdateInput;
  }) => YoutubePromise;
  deleteYoutube: (where: YoutubeWhereUniqueInput) => YoutubePromise;
  deleteManyYoutubes: (where?: YoutubeWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  feedback: (
    where?: FeedbackSubscriptionWhereInput
  ) => FeedbackSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  geo: (
    where?: GeoSubscriptionWhereInput
  ) => GeoSubscriptionPayloadSubscription;
  influencer: (
    where?: InfluencerSubscriptionWhereInput
  ) => InfluencerSubscriptionPayloadSubscription;
  instagram: (
    where?: InstagramSubscriptionWhereInput
  ) => InstagramSubscriptionPayloadSubscription;
  interest: (
    where?: InterestSubscriptionWhereInput
  ) => InterestSubscriptionPayloadSubscription;
  jobs: (
    where?: JobsSubscriptionWhereInput
  ) => JobsSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  mediaKit: (
    where?: MediaKitSubscriptionWhereInput
  ) => MediaKitSubscriptionPayloadSubscription;
  social: (
    where?: SocialSubscriptionWhereInput
  ) => SocialSubscriptionPayloadSubscription;
  twitter: (
    where?: TwitterSubscriptionWhereInput
  ) => TwitterSubscriptionPayloadSubscription;
  youtube: (
    where?: YoutubeSubscriptionWhereInput
  ) => YoutubeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type InfluencerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "handle_ASC"
  | "handle_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "name_ASC"
  | "name_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "password_ASC"
  | "password_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "specialty_ASC"
  | "specialty_DESC";

export type MediaKitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type GeoOrderByInput =
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type Status = "DRAFT" | "PUBLISHED" | "ARCHIVED";

export type FeedbackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "comment_ASC"
  | "comment_DESC";

export type TwitterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "analytics_ASC"
  | "analytics_DESC"
  | "followers_ASC"
  | "followers_DESC"
  | "handle_ASC"
  | "handle_DESC"
  | "link_ASC"
  | "link_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "url_ASC"
  | "url_DESC"
  | "public_id_ASC"
  | "public_id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "width_ASC"
  | "width_DESC"
  | "height_ASC"
  | "height_DESC"
  | "resource_type_ASC"
  | "resource_type_DESC"
  | "contentType_ASC"
  | "contentType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InterestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "tag_ASC"
  | "tag_DESC";

export type JobsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "accepted_ASC"
  | "accepted_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "location_ASC"
  | "location_DESC";

export type SocialOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type YoutubeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "followers_ASC"
  | "followers_DESC"
  | "analytics_ASC"
  | "analytics_DESC"
  | "handle_ASC"
  | "handle_DESC"
  | "link_ASC"
  | "link_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type InstagramOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "handle_ASC"
  | "handle_DESC"
  | "followers_ASC"
  | "followers_DESC"
  | "analytics_ASC"
  | "analytics_DESC"
  | "link_ASC"
  | "link_DESC";

export type LocationOrderByInput =
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export interface InfluencerUpdateWithoutFilesDataInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationUpdateOneWithoutInfluencerInput;
  mediaKit?: MediaKitUpdateManyWithoutInfluencerInput;
  social?: SocialUpdateOneWithoutInfluencerInput;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface YoutubeUpsertNestedInput {
  update: YoutubeUpdateDataInput;
  create: YoutubeCreateInput;
}

export interface SocialWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  instagram?: InstagramWhereInput;
  youtube?: YoutubeWhereInput;
  twitter?: TwitterWhereInput;
  influencer?: InfluencerWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: SocialWhereInput[] | SocialWhereInput;
  OR?: SocialWhereInput[] | SocialWhereInput;
  NOT?: SocialWhereInput[] | SocialWhereInput;
}

export interface TwitterUpdateOneInput {
  create?: TwitterCreateInput;
  update?: TwitterUpdateDataInput;
  upsert?: TwitterUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TwitterWhereUniqueInput;
}

export interface YoutubeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  followers?: Int;
  followers_not?: Int;
  followers_in?: Int[] | Int;
  followers_not_in?: Int[] | Int;
  followers_lt?: Int;
  followers_lte?: Int;
  followers_gt?: Int;
  followers_gte?: Int;
  handle?: String;
  handle_not?: String;
  handle_in?: String[] | String;
  handle_not_in?: String[] | String;
  handle_lt?: String;
  handle_lte?: String;
  handle_gt?: String;
  handle_gte?: String;
  handle_contains?: String;
  handle_not_contains?: String;
  handle_starts_with?: String;
  handle_not_starts_with?: String;
  handle_ends_with?: String;
  handle_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: YoutubeWhereInput[] | YoutubeWhereInput;
  OR?: YoutubeWhereInput[] | YoutubeWhereInput;
  NOT?: YoutubeWhereInput[] | YoutubeWhereInput;
}

export interface TwitterUpdateDataInput {
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface InterestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  tag?: String;
  tag_not?: String;
  tag_in?: String[] | String;
  tag_not_in?: String[] | String;
  tag_lt?: String;
  tag_lte?: String;
  tag_gt?: String;
  tag_gte?: String;
  tag_contains?: String;
  tag_not_contains?: String;
  tag_starts_with?: String;
  tag_not_starts_with?: String;
  tag_ends_with?: String;
  tag_not_ends_with?: String;
  influencer?: InfluencerWhereInput;
  AND?: InterestWhereInput[] | InterestWhereInput;
  OR?: InterestWhereInput[] | InterestWhereInput;
  NOT?: InterestWhereInput[] | InterestWhereInput;
}

export interface YoutubeCreateOneInput {
  create?: YoutubeCreateInput;
  connect?: YoutubeWhereUniqueInput;
}

export interface FileCreateInput {
  id?: ID_Input;
  secret: String;
  url: String;
  public_id: String;
  name: String;
  size: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType: String;
  influencer: InfluencerCreateOneWithoutFilesInput;
  mediaKit?: MediaKitCreateManyWithoutFilesInput;
}

export interface YoutubeCreateInput {
  id?: ID_Input;
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface TwitterUpsertNestedInput {
  update: TwitterUpdateDataInput;
  create: TwitterCreateInput;
}

export interface TwitterCreateOneInput {
  create?: TwitterCreateInput;
  connect?: TwitterWhereUniqueInput;
}

export interface GeoWhereInput {
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  location?: LocationWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: GeoWhereInput[] | GeoWhereInput;
  OR?: GeoWhereInput[] | GeoWhereInput;
  NOT?: GeoWhereInput[] | GeoWhereInput;
}

export interface TwitterCreateInput {
  id?: ID_Input;
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface SocialSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialWhereInput;
  AND?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  OR?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  NOT?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
}

export interface InterestCreateManyInput {
  create?: InterestCreateInput[] | InterestCreateInput;
  connect?: InterestWhereUniqueInput[] | InterestWhereUniqueInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface InterestCreateInput {
  id?: ID_Input;
  tag?: String;
  influencer?: InfluencerCreateOneInput;
}

export interface InterestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InterestWhereInput;
  AND?: InterestSubscriptionWhereInput[] | InterestSubscriptionWhereInput;
  OR?: InterestSubscriptionWhereInput[] | InterestSubscriptionWhereInput;
  NOT?: InterestSubscriptionWhereInput[] | InterestSubscriptionWhereInput;
}

export interface FileCreateManyWithoutInfluencerInput {
  create?:
    | FileCreateWithoutInfluencerInput[]
    | FileCreateWithoutInfluencerInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
}

export interface CompanyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  hires?: InfluencerWhereInput;
  jobs_every?: JobsWhereInput;
  jobs_some?: JobsWhereInput;
  jobs_none?: JobsWhereInput;
  feedback?: FeedbackWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface FileCreateWithoutInfluencerInput {
  id?: ID_Input;
  secret: String;
  url: String;
  public_id: String;
  name: String;
  size: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType: String;
  mediaKit?: MediaKitCreateManyWithoutFilesInput;
}

export interface LocationWhereInput {
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  geo?: GeoWhereInput;
  influencer?: InfluencerWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface MediaKitCreateManyWithoutFilesInput {
  create?: MediaKitCreateWithoutFilesInput[] | MediaKitCreateWithoutFilesInput;
  connect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
}

export interface InfluencerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InfluencerWhereInput;
  AND?: InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput;
  OR?: InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput;
  NOT?: InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput;
}

export interface MediaKitCreateWithoutFilesInput {
  id?: ID_Input;
  influencer?: InfluencerCreateOneWithoutMediaKitInput;
  interests?: InterestCreateManyInput;
  status?: Status;
}

export interface GeoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GeoWhereInput;
  AND?: GeoSubscriptionWhereInput[] | GeoSubscriptionWhereInput;
  OR?: GeoSubscriptionWhereInput[] | GeoSubscriptionWhereInput;
  NOT?: GeoSubscriptionWhereInput[] | GeoSubscriptionWhereInput;
}

export interface InfluencerCreateOneWithoutMediaKitInput {
  create?: InfluencerCreateWithoutMediaKitInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface FeedbackSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeedbackWhereInput;
  AND?: FeedbackSubscriptionWhereInput[] | FeedbackSubscriptionWhereInput;
  OR?: FeedbackSubscriptionWhereInput[] | FeedbackSubscriptionWhereInput;
  NOT?: FeedbackSubscriptionWhereInput[] | FeedbackSubscriptionWhereInput;
}

export interface InfluencerCreateWithoutMediaKitInput {
  id?: ID_Input;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationCreateOneWithoutInfluencerInput;
  files?: FileCreateManyWithoutInfluencerInput;
  social?: SocialCreateOneWithoutInfluencerInput;
}

export type FeedbackWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface JobsCreateManyWithoutCompanyInput {
  create?: JobsCreateWithoutCompanyInput[] | JobsCreateWithoutCompanyInput;
  connect?: JobsWhereUniqueInput[] | JobsWhereUniqueInput;
}

export interface YoutubeUpdateManyMutationInput {
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface JobsCreateWithoutCompanyInput {
  id?: ID_Input;
  status?: Status;
  cost?: String;
  accepted?: Boolean;
}

export interface TwitterUpdateManyMutationInput {
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface FeedbackCreateOneWithoutCompanyInput {
  create?: FeedbackCreateWithoutCompanyInput;
  connect?: FeedbackWhereUniqueInput;
}

export interface TwitterUpdateInput {
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface FeedbackCreateWithoutCompanyInput {
  id?: ID_Input;
  status?: Status;
  influencer?: InfluencerCreateOneInput;
  comment?: String;
}

export interface InfluencerUpsertWithoutSocialInput {
  update: InfluencerUpdateWithoutSocialDataInput;
  create: InfluencerCreateWithoutSocialInput;
}

export interface CompanyUpdateInput {
  status?: Status;
  hires?: InfluencerUpdateOneInput;
  jobs?: JobsUpdateManyWithoutCompanyInput;
  feedback?: FeedbackUpdateOneWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface InfluencerUpdateWithoutSocialDataInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationUpdateOneWithoutInfluencerInput;
  mediaKit?: MediaKitUpdateManyWithoutInfluencerInput;
  files?: FileUpdateManyWithoutInfluencerInput;
}

export interface InfluencerUpdateOneInput {
  create?: InfluencerCreateInput;
  update?: InfluencerUpdateDataInput;
  upsert?: InfluencerUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InfluencerWhereUniqueInput;
}

export interface SocialUpdateInput {
  status?: Status;
  instagram?: InstagramUpdateOneInput;
  youtube?: YoutubeUpdateOneInput;
  twitter?: TwitterUpdateOneInput;
  influencer?: InfluencerUpdateOneWithoutSocialInput;
}

export interface InfluencerUpdateDataInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationUpdateOneWithoutInfluencerInput;
  mediaKit?: MediaKitUpdateManyWithoutInfluencerInput;
  files?: FileUpdateManyWithoutInfluencerInput;
  social?: SocialUpdateOneWithoutInfluencerInput;
}

export type InfluencerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  handle?: String;
}>;

export interface LocationUpdateOneWithoutInfluencerInput {
  create?: LocationCreateWithoutInfluencerInput;
  update?: LocationUpdateWithoutInfluencerDataInput;
  upsert?: LocationUpsertWithoutInfluencerInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface SocialCreateInput {
  id?: ID_Input;
  status: Status;
  instagram?: InstagramCreateOneInput;
  youtube?: YoutubeCreateOneInput;
  twitter?: TwitterCreateOneInput;
  influencer?: InfluencerCreateOneWithoutSocialInput;
}

export interface LocationUpdateWithoutInfluencerDataInput {
  name?: String;
  geo?: GeoUpdateOneWithoutLocationInput;
}

export interface MediaKitUpdateInput {
  influencer?: InfluencerUpdateOneWithoutMediaKitInput;
  files?: FileUpdateManyWithoutMediaKitInput;
  interests?: InterestUpdateManyInput;
  status?: Status;
}

export interface GeoUpdateOneWithoutLocationInput {
  create?: GeoCreateWithoutLocationInput;
  update?: GeoUpdateWithoutLocationDataInput;
  upsert?: GeoUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GeoWhereUniqueInput;
}

export interface MediaKitCreateInput {
  id?: ID_Input;
  influencer?: InfluencerCreateOneWithoutMediaKitInput;
  files?: FileCreateManyWithoutMediaKitInput;
  interests?: InterestCreateManyInput;
  status?: Status;
}

export interface GeoUpdateWithoutLocationDataInput {
  lat?: Float;
  lng?: Float;
}

export interface LocationUpdateInput {
  name?: String;
  geo?: GeoUpdateOneWithoutLocationInput;
  influencer?: InfluencerUpdateOneWithoutLocationInput;
}

export interface GeoUpsertWithoutLocationInput {
  update: GeoUpdateWithoutLocationDataInput;
  create: GeoCreateWithoutLocationInput;
}

export type InterestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LocationUpsertWithoutInfluencerInput {
  update: LocationUpdateWithoutInfluencerDataInput;
  create: LocationCreateWithoutInfluencerInput;
}

export interface CompanyUpsertWithoutJobsInput {
  update: CompanyUpdateWithoutJobsDataInput;
  create: CompanyCreateWithoutJobsInput;
}

export interface MediaKitUpdateManyWithoutInfluencerInput {
  create?:
    | MediaKitCreateWithoutInfluencerInput[]
    | MediaKitCreateWithoutInfluencerInput;
  delete?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  connect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  set?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  disconnect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  update?:
    | MediaKitUpdateWithWhereUniqueWithoutInfluencerInput[]
    | MediaKitUpdateWithWhereUniqueWithoutInfluencerInput;
  upsert?:
    | MediaKitUpsertWithWhereUniqueWithoutInfluencerInput[]
    | MediaKitUpsertWithWhereUniqueWithoutInfluencerInput;
  deleteMany?: MediaKitScalarWhereInput[] | MediaKitScalarWhereInput;
  updateMany?:
    | MediaKitUpdateManyWithWhereNestedInput[]
    | MediaKitUpdateManyWithWhereNestedInput;
}

export type JobsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MediaKitUpdateWithWhereUniqueWithoutInfluencerInput {
  where: MediaKitWhereUniqueInput;
  data: MediaKitUpdateWithoutInfluencerDataInput;
}

export interface JobsUpdateInput {
  status?: Status;
  company?: CompanyUpdateOneWithoutJobsInput;
  cost?: String;
  accepted?: Boolean;
}

export interface MediaKitUpdateWithoutInfluencerDataInput {
  files?: FileUpdateManyWithoutMediaKitInput;
  interests?: InterestUpdateManyInput;
  status?: Status;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FileUpdateManyWithoutMediaKitInput {
  create?: FileCreateWithoutMediaKitInput[] | FileCreateWithoutMediaKitInput;
  delete?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  set?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  disconnect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  update?:
    | FileUpdateWithWhereUniqueWithoutMediaKitInput[]
    | FileUpdateWithWhereUniqueWithoutMediaKitInput;
  upsert?:
    | FileUpsertWithWhereUniqueWithoutMediaKitInput[]
    | FileUpsertWithWhereUniqueWithoutMediaKitInput;
  deleteMany?: FileScalarWhereInput[] | FileScalarWhereInput;
  updateMany?:
    | FileUpdateManyWithWhereNestedInput[]
    | FileUpdateManyWithWhereNestedInput;
}

export interface JobsCreateInput {
  id?: ID_Input;
  status?: Status;
  company?: CompanyCreateOneWithoutJobsInput;
  cost?: String;
  accepted?: Boolean;
}

export interface FileUpdateWithWhereUniqueWithoutMediaKitInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutMediaKitDataInput;
}

export interface InterestUpdateInput {
  tag?: String;
  influencer?: InfluencerUpdateOneInput;
}

export interface FileUpdateWithoutMediaKitDataInput {
  secret?: String;
  url?: String;
  public_id?: String;
  name?: String;
  size?: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType?: String;
  influencer?: InfluencerUpdateOneRequiredWithoutFilesInput;
}

export interface InstagramUpdateManyMutationInput {
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface InfluencerUpdateOneRequiredWithoutFilesInput {
  create?: InfluencerCreateWithoutFilesInput;
  update?: InfluencerUpdateWithoutFilesDataInput;
  upsert?: InfluencerUpsertWithoutFilesInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface InfluencerUpdateManyMutationInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
}

export interface LocationCreateOneWithoutGeoInput {
  create?: LocationCreateWithoutGeoInput;
  connect?: LocationWhereUniqueInput;
}

export interface InfluencerUpdateInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationUpdateOneWithoutInfluencerInput;
  mediaKit?: MediaKitUpdateManyWithoutInfluencerInput;
  files?: FileUpdateManyWithoutInfluencerInput;
  social?: SocialUpdateOneWithoutInfluencerInput;
}

export interface SocialUpdateOneWithoutInfluencerInput {
  create?: SocialCreateWithoutInfluencerInput;
  update?: SocialUpdateWithoutInfluencerDataInput;
  upsert?: SocialUpsertWithoutInfluencerInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SocialWhereUniqueInput;
}

export interface LocationUpsertWithoutGeoInput {
  update: LocationUpdateWithoutGeoDataInput;
  create: LocationCreateWithoutGeoInput;
}

export interface SocialUpdateWithoutInfluencerDataInput {
  status?: Status;
  instagram?: InstagramUpdateOneInput;
  youtube?: YoutubeUpdateOneInput;
  twitter?: TwitterUpdateOneInput;
}

export type TwitterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InstagramUpdateOneInput {
  create?: InstagramCreateInput;
  update?: InstagramUpdateDataInput;
  upsert?: InstagramUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InstagramWhereUniqueInput;
}

export interface InfluencerUpdateOneWithoutLocationInput {
  create?: InfluencerCreateWithoutLocationInput;
  update?: InfluencerUpdateWithoutLocationDataInput;
  upsert?: InfluencerUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InfluencerWhereUniqueInput;
}

export interface InstagramUpdateDataInput {
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface LocationUpdateOneWithoutGeoInput {
  create?: LocationCreateWithoutGeoInput;
  update?: LocationUpdateWithoutGeoDataInput;
  upsert?: LocationUpsertWithoutGeoInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface InstagramUpsertNestedInput {
  update: InstagramUpdateDataInput;
  create: InstagramCreateInput;
}

export interface GeoUpdateInput {
  lat?: Float;
  lng?: Float;
  location?: LocationUpdateOneWithoutGeoInput;
}

export interface YoutubeUpdateOneInput {
  create?: YoutubeCreateInput;
  update?: YoutubeUpdateDataInput;
  upsert?: YoutubeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: YoutubeWhereUniqueInput;
}

export interface InfluencerCreateOneWithoutLocationInput {
  create?: InfluencerCreateWithoutLocationInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface YoutubeUpdateDataInput {
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface InfluencerCreateOneInput {
  create?: InfluencerCreateInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface InstagramWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  handle?: String;
  handle_not?: String;
  handle_in?: String[] | String;
  handle_not_in?: String[] | String;
  handle_lt?: String;
  handle_lte?: String;
  handle_gt?: String;
  handle_gte?: String;
  handle_contains?: String;
  handle_not_contains?: String;
  handle_starts_with?: String;
  handle_not_starts_with?: String;
  handle_ends_with?: String;
  handle_not_ends_with?: String;
  followers?: Int;
  followers_not?: Int;
  followers_in?: Int[] | Int;
  followers_not_in?: Int[] | Int;
  followers_lt?: Int;
  followers_lte?: Int;
  followers_gt?: Int;
  followers_gte?: Int;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: InstagramWhereInput[] | InstagramWhereInput;
  OR?: InstagramWhereInput[] | InstagramWhereInput;
  NOT?: InstagramWhereInput[] | InstagramWhereInput;
}

export interface LocationCreateOneWithoutInfluencerInput {
  create?: LocationCreateWithoutInfluencerInput;
  connect?: LocationWhereUniqueInput;
}

export interface TwitterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  followers?: Int;
  followers_not?: Int;
  followers_in?: Int[] | Int;
  followers_not_in?: Int[] | Int;
  followers_lt?: Int;
  followers_lte?: Int;
  followers_gt?: Int;
  followers_gte?: Int;
  handle?: String;
  handle_not?: String;
  handle_in?: String[] | String;
  handle_not_in?: String[] | String;
  handle_lt?: String;
  handle_lte?: String;
  handle_gt?: String;
  handle_gte?: String;
  handle_contains?: String;
  handle_not_contains?: String;
  handle_starts_with?: String;
  handle_not_starts_with?: String;
  handle_ends_with?: String;
  handle_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: TwitterWhereInput[] | TwitterWhereInput;
  OR?: TwitterWhereInput[] | TwitterWhereInput;
  NOT?: TwitterWhereInput[] | TwitterWhereInput;
}

export interface GeoCreateOneWithoutLocationInput {
  create?: GeoCreateWithoutLocationInput;
  connect?: GeoWhereUniqueInput;
}

export interface GeoCreateInput {
  lat?: Float;
  lng?: Float;
  id?: ID_Input;
  location?: LocationCreateOneWithoutGeoInput;
}

export interface MediaKitCreateManyWithoutInfluencerInput {
  create?:
    | MediaKitCreateWithoutInfluencerInput[]
    | MediaKitCreateWithoutInfluencerInput;
  connect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  public_id?: String;
  public_id_not?: String;
  public_id_in?: String[] | String;
  public_id_not_in?: String[] | String;
  public_id_lt?: String;
  public_id_lte?: String;
  public_id_gt?: String;
  public_id_gte?: String;
  public_id_contains?: String;
  public_id_not_contains?: String;
  public_id_starts_with?: String;
  public_id_not_starts_with?: String;
  public_id_ends_with?: String;
  public_id_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  height?: Int;
  height_not?: Int;
  height_in?: Int[] | Int;
  height_not_in?: Int[] | Int;
  height_lt?: Int;
  height_lte?: Int;
  height_gt?: Int;
  height_gte?: Int;
  resource_type?: String;
  resource_type_not?: String;
  resource_type_in?: String[] | String;
  resource_type_not_in?: String[] | String;
  resource_type_lt?: String;
  resource_type_lte?: String;
  resource_type_gt?: String;
  resource_type_gte?: String;
  resource_type_contains?: String;
  resource_type_not_contains?: String;
  resource_type_starts_with?: String;
  resource_type_not_starts_with?: String;
  resource_type_ends_with?: String;
  resource_type_not_ends_with?: String;
  contentType?: String;
  contentType_not?: String;
  contentType_in?: String[] | String;
  contentType_not_in?: String[] | String;
  contentType_lt?: String;
  contentType_lte?: String;
  contentType_gt?: String;
  contentType_gte?: String;
  contentType_contains?: String;
  contentType_not_contains?: String;
  contentType_starts_with?: String;
  contentType_not_starts_with?: String;
  contentType_ends_with?: String;
  contentType_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  influencer?: InfluencerWhereInput;
  mediaKit_every?: MediaKitWhereInput;
  mediaKit_some?: MediaKitWhereInput;
  mediaKit_none?: MediaKitWhereInput;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface FileCreateManyWithoutMediaKitInput {
  create?: FileCreateWithoutMediaKitInput[] | FileCreateWithoutMediaKitInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
}

export interface SocialUpsertWithoutInfluencerInput {
  update: SocialUpdateWithoutInfluencerDataInput;
  create: SocialCreateWithoutInfluencerInput;
}

export interface InfluencerCreateOneWithoutFilesInput {
  create?: InfluencerCreateWithoutFilesInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface InfluencerUpsertWithoutFilesInput {
  update: InfluencerUpdateWithoutFilesDataInput;
  create: InfluencerCreateWithoutFilesInput;
}

export interface SocialCreateOneWithoutInfluencerInput {
  create?: SocialCreateWithoutInfluencerInput;
  connect?: SocialWhereUniqueInput;
}

export interface FileUpsertWithWhereUniqueWithoutMediaKitInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutMediaKitDataInput;
  create: FileCreateWithoutMediaKitInput;
}

export interface InstagramCreateOneInput {
  create?: InstagramCreateInput;
  connect?: InstagramWhereUniqueInput;
}

export interface FileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  public_id?: String;
  public_id_not?: String;
  public_id_in?: String[] | String;
  public_id_not_in?: String[] | String;
  public_id_lt?: String;
  public_id_lte?: String;
  public_id_gt?: String;
  public_id_gte?: String;
  public_id_contains?: String;
  public_id_not_contains?: String;
  public_id_starts_with?: String;
  public_id_not_starts_with?: String;
  public_id_ends_with?: String;
  public_id_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  height?: Int;
  height_not?: Int;
  height_in?: Int[] | Int;
  height_not_in?: Int[] | Int;
  height_lt?: Int;
  height_lte?: Int;
  height_gt?: Int;
  height_gte?: Int;
  resource_type?: String;
  resource_type_not?: String;
  resource_type_in?: String[] | String;
  resource_type_not_in?: String[] | String;
  resource_type_lt?: String;
  resource_type_lte?: String;
  resource_type_gt?: String;
  resource_type_gte?: String;
  resource_type_contains?: String;
  resource_type_not_contains?: String;
  resource_type_starts_with?: String;
  resource_type_not_starts_with?: String;
  resource_type_ends_with?: String;
  resource_type_not_ends_with?: String;
  contentType?: String;
  contentType_not?: String;
  contentType_in?: String[] | String;
  contentType_not_in?: String[] | String;
  contentType_lt?: String;
  contentType_lte?: String;
  contentType_gt?: String;
  contentType_gte?: String;
  contentType_contains?: String;
  contentType_not_contains?: String;
  contentType_starts_with?: String;
  contentType_not_starts_with?: String;
  contentType_ends_with?: String;
  contentType_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FileScalarWhereInput[] | FileScalarWhereInput;
  OR?: FileScalarWhereInput[] | FileScalarWhereInput;
  NOT?: FileScalarWhereInput[] | FileScalarWhereInput;
}

export interface YoutubeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: YoutubeWhereInput;
  AND?: YoutubeSubscriptionWhereInput[] | YoutubeSubscriptionWhereInput;
  OR?: YoutubeSubscriptionWhereInput[] | YoutubeSubscriptionWhereInput;
  NOT?: YoutubeSubscriptionWhereInput[] | YoutubeSubscriptionWhereInput;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface MediaKitSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MediaKitWhereInput;
  AND?: MediaKitSubscriptionWhereInput[] | MediaKitSubscriptionWhereInput;
  OR?: MediaKitSubscriptionWhereInput[] | MediaKitSubscriptionWhereInput;
  NOT?: MediaKitSubscriptionWhereInput[] | MediaKitSubscriptionWhereInput;
}

export interface FileUpdateManyDataInput {
  secret?: String;
  url?: String;
  public_id?: String;
  name?: String;
  size?: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType?: String;
}

export interface JobsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  company?: CompanyWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  cost?: String;
  cost_not?: String;
  cost_in?: String[] | String;
  cost_not_in?: String[] | String;
  cost_lt?: String;
  cost_lte?: String;
  cost_gt?: String;
  cost_gte?: String;
  cost_contains?: String;
  cost_not_contains?: String;
  cost_starts_with?: String;
  cost_not_starts_with?: String;
  cost_ends_with?: String;
  cost_not_ends_with?: String;
  accepted?: Boolean;
  accepted_not?: Boolean;
  AND?: JobsWhereInput[] | JobsWhereInput;
  OR?: JobsWhereInput[] | JobsWhereInput;
  NOT?: JobsWhereInput[] | JobsWhereInput;
}

export interface InterestUpdateManyInput {
  create?: InterestCreateInput[] | InterestCreateInput;
  update?:
    | InterestUpdateWithWhereUniqueNestedInput[]
    | InterestUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InterestUpsertWithWhereUniqueNestedInput[]
    | InterestUpsertWithWhereUniqueNestedInput;
  delete?: InterestWhereUniqueInput[] | InterestWhereUniqueInput;
  connect?: InterestWhereUniqueInput[] | InterestWhereUniqueInput;
  set?: InterestWhereUniqueInput[] | InterestWhereUniqueInput;
  disconnect?: InterestWhereUniqueInput[] | InterestWhereUniqueInput;
  deleteMany?: InterestScalarWhereInput[] | InterestScalarWhereInput;
  updateMany?:
    | InterestUpdateManyWithWhereNestedInput[]
    | InterestUpdateManyWithWhereNestedInput;
}

export interface InstagramSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InstagramWhereInput;
  AND?: InstagramSubscriptionWhereInput[] | InstagramSubscriptionWhereInput;
  OR?: InstagramSubscriptionWhereInput[] | InstagramSubscriptionWhereInput;
  NOT?: InstagramSubscriptionWhereInput[] | InstagramSubscriptionWhereInput;
}

export interface InterestUpdateWithWhereUniqueNestedInput {
  where: InterestWhereUniqueInput;
  data: InterestUpdateDataInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface InterestUpdateDataInput {
  tag?: String;
  influencer?: InfluencerUpdateOneInput;
}

export interface MediaKitWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  influencer?: InfluencerWhereInput;
  files_every?: FileWhereInput;
  files_some?: FileWhereInput;
  files_none?: FileWhereInput;
  interests_every?: InterestWhereInput;
  interests_some?: InterestWhereInput;
  interests_none?: InterestWhereInput;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MediaKitWhereInput[] | MediaKitWhereInput;
  OR?: MediaKitWhereInput[] | MediaKitWhereInput;
  NOT?: MediaKitWhereInput[] | MediaKitWhereInput;
}

export interface InterestUpsertWithWhereUniqueNestedInput {
  where: InterestWhereUniqueInput;
  update: InterestUpdateDataInput;
  create: InterestCreateInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  secret?: String;
  url?: String;
}>;

export interface InterestScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  tag?: String;
  tag_not?: String;
  tag_in?: String[] | String;
  tag_not_in?: String[] | String;
  tag_lt?: String;
  tag_lte?: String;
  tag_gt?: String;
  tag_gte?: String;
  tag_contains?: String;
  tag_not_contains?: String;
  tag_starts_with?: String;
  tag_not_starts_with?: String;
  tag_ends_with?: String;
  tag_not_ends_with?: String;
  AND?: InterestScalarWhereInput[] | InterestScalarWhereInput;
  OR?: InterestScalarWhereInput[] | InterestScalarWhereInput;
  NOT?: InterestScalarWhereInput[] | InterestScalarWhereInput;
}

export type GeoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InterestUpdateManyWithWhereNestedInput {
  where: InterestScalarWhereInput;
  data: InterestUpdateManyDataInput;
}

export interface InfluencerCreateWithoutSocialInput {
  id?: ID_Input;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationCreateOneWithoutInfluencerInput;
  mediaKit?: MediaKitCreateManyWithoutInfluencerInput;
  files?: FileCreateManyWithoutInfluencerInput;
}

export interface InterestUpdateManyDataInput {
  tag?: String;
}

export interface MediaKitUpdateManyMutationInput {
  status?: Status;
}

export interface MediaKitUpsertWithWhereUniqueWithoutInfluencerInput {
  where: MediaKitWhereUniqueInput;
  update: MediaKitUpdateWithoutInfluencerDataInput;
  create: MediaKitCreateWithoutInfluencerInput;
}

export interface LocationUpdateManyMutationInput {
  name?: String;
}

export interface MediaKitScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MediaKitScalarWhereInput[] | MediaKitScalarWhereInput;
  OR?: MediaKitScalarWhereInput[] | MediaKitScalarWhereInput;
  NOT?: MediaKitScalarWhereInput[] | MediaKitScalarWhereInput;
}

export interface JobsUpdateManyMutationInput {
  status?: Status;
  cost?: String;
  accepted?: Boolean;
}

export interface MediaKitUpdateManyWithWhereNestedInput {
  where: MediaKitScalarWhereInput;
  data: MediaKitUpdateManyDataInput;
}

export interface CompanyUpdateOneWithoutJobsInput {
  create?: CompanyCreateWithoutJobsInput;
  update?: CompanyUpdateWithoutJobsDataInput;
  upsert?: CompanyUpsertWithoutJobsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface MediaKitUpdateManyDataInput {
  status?: Status;
}

export interface CompanyCreateOneWithoutJobsInput {
  create?: CompanyCreateWithoutJobsInput;
  connect?: CompanyWhereUniqueInput;
}

export interface FileUpdateManyWithoutInfluencerInput {
  create?:
    | FileCreateWithoutInfluencerInput[]
    | FileCreateWithoutInfluencerInput;
  delete?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  set?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  disconnect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  update?:
    | FileUpdateWithWhereUniqueWithoutInfluencerInput[]
    | FileUpdateWithWhereUniqueWithoutInfluencerInput;
  upsert?:
    | FileUpsertWithWhereUniqueWithoutInfluencerInput[]
    | FileUpsertWithWhereUniqueWithoutInfluencerInput;
  deleteMany?: FileScalarWhereInput[] | FileScalarWhereInput;
  updateMany?:
    | FileUpdateManyWithWhereNestedInput[]
    | FileUpdateManyWithWhereNestedInput;
}

export type MediaKitWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FileUpdateWithWhereUniqueWithoutInfluencerInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutInfluencerDataInput;
}

export type SocialWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FileUpdateWithoutInfluencerDataInput {
  secret?: String;
  url?: String;
  public_id?: String;
  name?: String;
  size?: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType?: String;
  mediaKit?: MediaKitUpdateManyWithoutFilesInput;
}

export interface InfluencerUpsertWithoutLocationInput {
  update: InfluencerUpdateWithoutLocationDataInput;
  create: InfluencerCreateWithoutLocationInput;
}

export interface MediaKitUpdateManyWithoutFilesInput {
  create?: MediaKitCreateWithoutFilesInput[] | MediaKitCreateWithoutFilesInput;
  delete?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  connect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  set?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  disconnect?: MediaKitWhereUniqueInput[] | MediaKitWhereUniqueInput;
  update?:
    | MediaKitUpdateWithWhereUniqueWithoutFilesInput[]
    | MediaKitUpdateWithWhereUniqueWithoutFilesInput;
  upsert?:
    | MediaKitUpsertWithWhereUniqueWithoutFilesInput[]
    | MediaKitUpsertWithWhereUniqueWithoutFilesInput;
  deleteMany?: MediaKitScalarWhereInput[] | MediaKitScalarWhereInput;
  updateMany?:
    | MediaKitUpdateManyWithWhereNestedInput[]
    | MediaKitUpdateManyWithWhereNestedInput;
}

export interface LocationUpdateWithoutGeoDataInput {
  name?: String;
  influencer?: InfluencerUpdateOneWithoutLocationInput;
}

export interface MediaKitUpdateWithWhereUniqueWithoutFilesInput {
  where: MediaKitWhereUniqueInput;
  data: MediaKitUpdateWithoutFilesDataInput;
}

export interface InfluencerCreateWithoutLocationInput {
  id?: ID_Input;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password: String;
  verified?: Boolean;
  specialty?: String;
  mediaKit?: MediaKitCreateManyWithoutInfluencerInput;
  files?: FileCreateManyWithoutInfluencerInput;
  social?: SocialCreateOneWithoutInfluencerInput;
}

export interface MediaKitUpdateWithoutFilesDataInput {
  influencer?: InfluencerUpdateOneWithoutMediaKitInput;
  interests?: InterestUpdateManyInput;
  status?: Status;
}

export interface CompanyCreateInput {
  id?: ID_Input;
  status?: Status;
  hires?: InfluencerCreateOneInput;
  jobs?: JobsCreateManyWithoutCompanyInput;
  feedback?: FeedbackCreateOneWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface InfluencerUpdateOneWithoutMediaKitInput {
  create?: InfluencerCreateWithoutMediaKitInput;
  update?: InfluencerUpdateWithoutMediaKitDataInput;
  upsert?: InfluencerUpsertWithoutMediaKitInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InfluencerWhereUniqueInput;
}

export interface LocationCreateWithoutInfluencerInput {
  id?: ID_Input;
  name?: String;
  geo?: GeoCreateOneWithoutLocationInput;
}

export interface InfluencerUpdateWithoutMediaKitDataInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationUpdateOneWithoutInfluencerInput;
  files?: FileUpdateManyWithoutInfluencerInput;
  social?: SocialUpdateOneWithoutInfluencerInput;
}

export interface MediaKitCreateWithoutInfluencerInput {
  id?: ID_Input;
  files?: FileCreateManyWithoutMediaKitInput;
  interests?: InterestCreateManyInput;
  status?: Status;
}

export interface InfluencerUpsertWithoutMediaKitInput {
  update: InfluencerUpdateWithoutMediaKitDataInput;
  create: InfluencerCreateWithoutMediaKitInput;
}

export interface InfluencerCreateWithoutFilesInput {
  id?: ID_Input;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationCreateOneWithoutInfluencerInput;
  mediaKit?: MediaKitCreateManyWithoutInfluencerInput;
  social?: SocialCreateOneWithoutInfluencerInput;
}

export interface MediaKitUpsertWithWhereUniqueWithoutFilesInput {
  where: MediaKitWhereUniqueInput;
  update: MediaKitUpdateWithoutFilesDataInput;
  create: MediaKitCreateWithoutFilesInput;
}

export interface InstagramCreateInput {
  id?: ID_Input;
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface FileUpsertWithWhereUniqueWithoutInfluencerInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutInfluencerDataInput;
  create: FileCreateWithoutInfluencerInput;
}

export interface JobsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JobsWhereInput;
  AND?: JobsSubscriptionWhereInput[] | JobsSubscriptionWhereInput;
  OR?: JobsSubscriptionWhereInput[] | JobsSubscriptionWhereInput;
  NOT?: JobsSubscriptionWhereInput[] | JobsSubscriptionWhereInput;
}

export interface InfluencerUpsertNestedInput {
  update: InfluencerUpdateDataInput;
  create: InfluencerCreateInput;
}

export interface InfluencerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  handle?: String;
  handle_not?: String;
  handle_in?: String[] | String;
  handle_not_in?: String[] | String;
  handle_lt?: String;
  handle_lte?: String;
  handle_gt?: String;
  handle_gte?: String;
  handle_contains?: String;
  handle_not_contains?: String;
  handle_starts_with?: String;
  handle_not_starts_with?: String;
  handle_ends_with?: String;
  handle_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  verified?: Boolean;
  verified_not?: Boolean;
  specialty?: String;
  specialty_not?: String;
  specialty_in?: String[] | String;
  specialty_not_in?: String[] | String;
  specialty_lt?: String;
  specialty_lte?: String;
  specialty_gt?: String;
  specialty_gte?: String;
  specialty_contains?: String;
  specialty_not_contains?: String;
  specialty_starts_with?: String;
  specialty_not_starts_with?: String;
  specialty_ends_with?: String;
  specialty_not_ends_with?: String;
  location?: LocationWhereInput;
  mediaKit_every?: MediaKitWhereInput;
  mediaKit_some?: MediaKitWhereInput;
  mediaKit_none?: MediaKitWhereInput;
  files_every?: FileWhereInput;
  files_some?: FileWhereInput;
  files_none?: FileWhereInput;
  social?: SocialWhereInput;
  AND?: InfluencerWhereInput[] | InfluencerWhereInput;
  OR?: InfluencerWhereInput[] | InfluencerWhereInput;
  NOT?: InfluencerWhereInput[] | InfluencerWhereInput;
}

export interface JobsUpdateManyWithoutCompanyInput {
  create?: JobsCreateWithoutCompanyInput[] | JobsCreateWithoutCompanyInput;
  delete?: JobsWhereUniqueInput[] | JobsWhereUniqueInput;
  connect?: JobsWhereUniqueInput[] | JobsWhereUniqueInput;
  set?: JobsWhereUniqueInput[] | JobsWhereUniqueInput;
  disconnect?: JobsWhereUniqueInput[] | JobsWhereUniqueInput;
  update?:
    | JobsUpdateWithWhereUniqueWithoutCompanyInput[]
    | JobsUpdateWithWhereUniqueWithoutCompanyInput;
  upsert?:
    | JobsUpsertWithWhereUniqueWithoutCompanyInput[]
    | JobsUpsertWithWhereUniqueWithoutCompanyInput;
  deleteMany?: JobsScalarWhereInput[] | JobsScalarWhereInput;
  updateMany?:
    | JobsUpdateManyWithWhereNestedInput[]
    | JobsUpdateManyWithWhereNestedInput;
}

export interface YoutubeUpdateInput {
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface JobsUpdateWithWhereUniqueWithoutCompanyInput {
  where: JobsWhereUniqueInput;
  data: JobsUpdateWithoutCompanyDataInput;
}

export interface InfluencerUpdateOneWithoutSocialInput {
  create?: InfluencerCreateWithoutSocialInput;
  update?: InfluencerUpdateWithoutSocialDataInput;
  upsert?: InfluencerUpsertWithoutSocialInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InfluencerWhereUniqueInput;
}

export interface JobsUpdateWithoutCompanyDataInput {
  status?: Status;
  cost?: String;
  accepted?: Boolean;
}

export type InstagramWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface JobsUpsertWithWhereUniqueWithoutCompanyInput {
  where: JobsWhereUniqueInput;
  update: JobsUpdateWithoutCompanyDataInput;
  create: JobsCreateWithoutCompanyInput;
}

export interface CompanyUpdateWithoutJobsDataInput {
  status?: Status;
  hires?: InfluencerUpdateOneInput;
  feedback?: FeedbackUpdateOneWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface JobsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  cost?: String;
  cost_not?: String;
  cost_in?: String[] | String;
  cost_not_in?: String[] | String;
  cost_lt?: String;
  cost_lte?: String;
  cost_gt?: String;
  cost_gte?: String;
  cost_contains?: String;
  cost_not_contains?: String;
  cost_starts_with?: String;
  cost_not_starts_with?: String;
  cost_ends_with?: String;
  cost_not_ends_with?: String;
  accepted?: Boolean;
  accepted_not?: Boolean;
  AND?: JobsScalarWhereInput[] | JobsScalarWhereInput;
  OR?: JobsScalarWhereInput[] | JobsScalarWhereInput;
  NOT?: JobsScalarWhereInput[] | JobsScalarWhereInput;
}

export interface InterestUpdateManyMutationInput {
  tag?: String;
}

export interface JobsUpdateManyWithWhereNestedInput {
  where: JobsScalarWhereInput;
  data: JobsUpdateManyDataInput;
}

export interface GeoUpdateManyMutationInput {
  lat?: Float;
  lng?: Float;
}

export interface JobsUpdateManyDataInput {
  status?: Status;
  cost?: String;
  accepted?: Boolean;
}

export type YoutubeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FeedbackUpdateOneWithoutCompanyInput {
  create?: FeedbackCreateWithoutCompanyInput;
  update?: FeedbackUpdateWithoutCompanyDataInput;
  upsert?: FeedbackUpsertWithoutCompanyInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FeedbackWhereUniqueInput;
}

export interface InfluencerCreateInput {
  id?: ID_Input;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password: String;
  verified?: Boolean;
  specialty?: String;
  location?: LocationCreateOneWithoutInfluencerInput;
  mediaKit?: MediaKitCreateManyWithoutInfluencerInput;
  files?: FileCreateManyWithoutInfluencerInput;
  social?: SocialCreateOneWithoutInfluencerInput;
}

export interface FeedbackUpdateWithoutCompanyDataInput {
  status?: Status;
  influencer?: InfluencerUpdateOneInput;
  comment?: String;
}

export interface FileCreateWithoutMediaKitInput {
  id?: ID_Input;
  secret: String;
  url: String;
  public_id: String;
  name: String;
  size: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType: String;
  influencer: InfluencerCreateOneWithoutFilesInput;
}

export interface FeedbackUpsertWithoutCompanyInput {
  update: FeedbackUpdateWithoutCompanyDataInput;
  create: FeedbackCreateWithoutCompanyInput;
}

export interface TwitterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TwitterWhereInput;
  AND?: TwitterSubscriptionWhereInput[] | TwitterSubscriptionWhereInput;
  OR?: TwitterSubscriptionWhereInput[] | TwitterSubscriptionWhereInput;
  NOT?: TwitterSubscriptionWhereInput[] | TwitterSubscriptionWhereInput;
}

export interface CompanyUpdateManyMutationInput {
  status?: Status;
  name?: String;
  location?: Json;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface FileUpdateManyMutationInput {
  secret?: String;
  url?: String;
  public_id?: String;
  name?: String;
  size?: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType?: String;
}

export interface InfluencerCreateOneWithoutSocialInput {
  create?: InfluencerCreateWithoutSocialInput;
  connect?: InfluencerWhereUniqueInput;
}

export interface FileUpdateInput {
  secret?: String;
  url?: String;
  public_id?: String;
  name?: String;
  size?: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType?: String;
  influencer?: InfluencerUpdateOneRequiredWithoutFilesInput;
  mediaKit?: MediaKitUpdateManyWithoutFilesInput;
}

export interface CompanyCreateWithoutJobsInput {
  id?: ID_Input;
  status?: Status;
  hires?: InfluencerCreateOneInput;
  feedback?: FeedbackCreateOneWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface FeedbackCreateInput {
  id?: ID_Input;
  status?: Status;
  influencer?: InfluencerCreateOneInput;
  company?: CompanyCreateOneWithoutFeedbackInput;
  comment?: String;
}

export interface InfluencerUpdateWithoutLocationDataInput {
  email?: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  password?: String;
  verified?: Boolean;
  specialty?: String;
  mediaKit?: MediaKitUpdateManyWithoutInfluencerInput;
  files?: FileUpdateManyWithoutInfluencerInput;
  social?: SocialUpdateOneWithoutInfluencerInput;
}

export interface CompanyCreateOneWithoutFeedbackInput {
  create?: CompanyCreateWithoutFeedbackInput;
  connect?: CompanyWhereUniqueInput;
}

export interface GeoCreateWithoutLocationInput {
  lat?: Float;
  lng?: Float;
  id?: ID_Input;
}

export interface CompanyCreateWithoutFeedbackInput {
  id?: ID_Input;
  status?: Status;
  hires?: InfluencerCreateOneInput;
  jobs?: JobsCreateManyWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface FeedbackWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  influencer?: InfluencerWhereInput;
  company?: CompanyWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  comment?: String;
  comment_not?: String;
  comment_in?: String[] | String;
  comment_not_in?: String[] | String;
  comment_lt?: String;
  comment_lte?: String;
  comment_gt?: String;
  comment_gte?: String;
  comment_contains?: String;
  comment_not_contains?: String;
  comment_starts_with?: String;
  comment_not_starts_with?: String;
  comment_ends_with?: String;
  comment_not_ends_with?: String;
  AND?: FeedbackWhereInput[] | FeedbackWhereInput;
  OR?: FeedbackWhereInput[] | FeedbackWhereInput;
  NOT?: FeedbackWhereInput[] | FeedbackWhereInput;
}

export interface FeedbackUpdateInput {
  status?: Status;
  influencer?: InfluencerUpdateOneInput;
  company?: CompanyUpdateOneWithoutFeedbackInput;
  comment?: String;
}

export interface LocationCreateInput {
  id?: ID_Input;
  name?: String;
  geo?: GeoCreateOneWithoutLocationInput;
  influencer?: InfluencerCreateOneWithoutLocationInput;
}

export interface FeedbackUpdateManyMutationInput {
  status?: Status;
  comment?: String;
}

export interface CompanyUpsertWithoutFeedbackInput {
  update: CompanyUpdateWithoutFeedbackDataInput;
  create: CompanyCreateWithoutFeedbackInput;
}

export interface CompanyUpdateWithoutFeedbackDataInput {
  status?: Status;
  hires?: InfluencerUpdateOneInput;
  jobs?: JobsUpdateManyWithoutCompanyInput;
  name?: String;
  location?: Json;
}

export interface CompanyUpdateOneWithoutFeedbackInput {
  create?: CompanyCreateWithoutFeedbackInput;
  update?: CompanyUpdateWithoutFeedbackDataInput;
  upsert?: CompanyUpsertWithoutFeedbackInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface InstagramUpdateInput {
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface SocialUpdateManyMutationInput {
  status?: Status;
}

export interface SocialCreateWithoutInfluencerInput {
  id?: ID_Input;
  status: Status;
  instagram?: InstagramCreateOneInput;
  youtube?: YoutubeCreateOneInput;
  twitter?: TwitterCreateOneInput;
}

export interface LocationCreateWithoutGeoInput {
  id?: ID_Input;
  name?: String;
  influencer?: InfluencerCreateOneWithoutLocationInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface YoutubePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface YoutubePreviousValuesPromise
  extends Promise<YoutubePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  followers: () => Promise<Int>;
  analytics: () => Promise<Json>;
  handle: () => Promise<String>;
  link: () => Promise<String>;
}

export interface YoutubePreviousValuesSubscription
  extends Promise<AsyncIterator<YoutubePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  followers: () => Promise<AsyncIterator<Int>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  handle: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface MediaKit {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface MediaKitPromise extends Promise<MediaKit>, Fragmentable {
  id: () => Promise<ID_Output>;
  influencer: <T = InfluencerPromise>() => T;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interests: <T = FragmentableArray<Interest>>(args?: {
    where?: InterestWhereInput;
    orderBy?: InterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MediaKitSubscription
  extends Promise<AsyncIterator<MediaKit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  influencer: <T = InfluencerSubscription>() => T;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interests: <T = Promise<AsyncIterator<InterestSubscription>>>(args?: {
    where?: InterestWhereInput;
    orderBy?: InterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialSubscriptionPayload {
  mutation: MutationType;
  node: Social;
  updatedFields: String[];
  previousValues: SocialPreviousValues;
}

export interface SocialSubscriptionPayloadPromise
  extends Promise<SocialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialPreviousValuesPromise>() => T;
}

export interface SocialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialPreviousValuesSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFeedback {
  count: Int;
}

export interface AggregateFeedbackPromise
  extends Promise<AggregateFeedback>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeedbackSubscription
  extends Promise<AsyncIterator<AggregateFeedback>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface YoutubeEdge {
  node: Youtube;
  cursor: String;
}

export interface YoutubeEdgePromise extends Promise<YoutubeEdge>, Fragmentable {
  node: <T = YoutubePromise>() => T;
  cursor: () => Promise<String>;
}

export interface YoutubeEdgeSubscription
  extends Promise<AsyncIterator<YoutubeEdge>>,
    Fragmentable {
  node: <T = YoutubeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Interest {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  tag?: String;
}

export interface InterestPromise extends Promise<Interest>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  tag: () => Promise<String>;
  influencer: <T = InfluencerPromise>() => T;
}

export interface InterestSubscription
  extends Promise<AsyncIterator<Interest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  tag: () => Promise<AsyncIterator<String>>;
  influencer: <T = InfluencerSubscription>() => T;
}

export interface Influencer {
  id: ID_Output;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  password: String;
  verified?: Boolean;
  specialty?: String;
}

export interface InfluencerPromise extends Promise<Influencer>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  handle: () => Promise<String>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  verified: () => Promise<Boolean>;
  specialty: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  mediaKit: <T = FragmentableArray<MediaKit>>(args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  social: <T = SocialPromise>() => T;
}

export interface InfluencerSubscription
  extends Promise<AsyncIterator<Influencer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  handle: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  specialty: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  mediaKit: <T = Promise<AsyncIterator<MediaKitSubscription>>>(args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  social: <T = SocialSubscription>() => T;
}

export interface FeedbackEdge {
  node: Feedback;
  cursor: String;
}

export interface FeedbackEdgePromise
  extends Promise<FeedbackEdge>,
    Fragmentable {
  node: <T = FeedbackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeedbackEdgeSubscription
  extends Promise<AsyncIterator<FeedbackEdge>>,
    Fragmentable {
  node: <T = FeedbackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TwitterEdge {
  node: Twitter;
  cursor: String;
}

export interface TwitterEdgePromise extends Promise<TwitterEdge>, Fragmentable {
  node: <T = TwitterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TwitterEdgeSubscription
  extends Promise<AsyncIterator<TwitterEdge>>,
    Fragmentable {
  node: <T = TwitterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FeedbackConnection {
  pageInfo: PageInfo;
  edges: FeedbackEdge[];
}

export interface FeedbackConnectionPromise
  extends Promise<FeedbackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeedbackEdge>>() => T;
  aggregate: <T = AggregateFeedbackPromise>() => T;
}

export interface FeedbackConnectionSubscription
  extends Promise<AsyncIterator<FeedbackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeedbackEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeedbackSubscription>() => T;
}

export interface YoutubeSubscriptionPayload {
  mutation: MutationType;
  node: Youtube;
  updatedFields: String[];
  previousValues: YoutubePreviousValues;
}

export interface YoutubeSubscriptionPayloadPromise
  extends Promise<YoutubeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = YoutubePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = YoutubePreviousValuesPromise>() => T;
}

export interface YoutubeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<YoutubeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = YoutubeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = YoutubePreviousValuesSubscription>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialEdge {
  node: Social;
  cursor: String;
}

export interface SocialEdgePromise extends Promise<SocialEdge>, Fragmentable {
  node: <T = SocialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialEdgeSubscription
  extends Promise<AsyncIterator<SocialEdge>>,
    Fragmentable {
  node: <T = SocialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Company {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  location?: Json;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  hires: <T = InfluencerPromise>() => T;
  jobs: <T = FragmentableArray<Jobs>>(args?: {
    where?: JobsWhereInput;
    orderBy?: JobsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  feedback: <T = FeedbackPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  location: () => Promise<Json>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  hires: <T = InfluencerSubscription>() => T;
  jobs: <T = Promise<AsyncIterator<JobsSubscription>>>(args?: {
    where?: JobsWhereInput;
    orderBy?: JobsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  feedback: <T = FeedbackSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<Json>>;
}

export interface File {
  id: ID_Output;
  secret: String;
  url: String;
  public_id: String;
  name: String;
  size: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  secret: () => Promise<String>;
  url: () => Promise<String>;
  public_id: () => Promise<String>;
  name: () => Promise<String>;
  size: () => Promise<Int>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
  resource_type: () => Promise<String>;
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  influencer: <T = InfluencerPromise>() => T;
  mediaKit: <T = FragmentableArray<MediaKit>>(args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  secret: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  public_id: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
  resource_type: () => Promise<AsyncIterator<String>>;
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  influencer: <T = InfluencerSubscription>() => T;
  mediaKit: <T = Promise<AsyncIterator<MediaKitSubscription>>>(args?: {
    where?: MediaKitWhereInput;
    orderBy?: MediaKitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface MediaKitEdge {
  node: MediaKit;
  cursor: String;
}

export interface MediaKitEdgePromise
  extends Promise<MediaKitEdge>,
    Fragmentable {
  node: <T = MediaKitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MediaKitEdgeSubscription
  extends Promise<AsyncIterator<MediaKitEdge>>,
    Fragmentable {
  node: <T = MediaKitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  location?: Json;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  location: () => Promise<Json>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<Json>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface FeedbackSubscriptionPayload {
  mutation: MutationType;
  node: Feedback;
  updatedFields: String[];
  previousValues: FeedbackPreviousValues;
}

export interface FeedbackSubscriptionPayloadPromise
  extends Promise<FeedbackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeedbackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeedbackPreviousValuesPromise>() => T;
}

export interface FeedbackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeedbackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeedbackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeedbackPreviousValuesSubscription>() => T;
}

export interface AggregateJobs {
  count: Int;
}

export interface AggregateJobsPromise
  extends Promise<AggregateJobs>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobsSubscription
  extends Promise<AsyncIterator<AggregateJobs>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FeedbackPreviousValues {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  comment?: String;
}

export interface FeedbackPreviousValuesPromise
  extends Promise<FeedbackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  comment: () => Promise<String>;
}

export interface FeedbackPreviousValuesSubscription
  extends Promise<AsyncIterator<FeedbackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  comment: () => Promise<AsyncIterator<String>>;
}

export interface JobsConnection {
  pageInfo: PageInfo;
  edges: JobsEdge[];
}

export interface JobsConnectionPromise
  extends Promise<JobsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobsEdge>>() => T;
  aggregate: <T = AggregateJobsPromise>() => T;
}

export interface JobsConnectionSubscription
  extends Promise<AsyncIterator<JobsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobsSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface InterestEdge {
  node: Interest;
  cursor: String;
}

export interface InterestEdgePromise
  extends Promise<InterestEdge>,
    Fragmentable {
  node: <T = InterestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InterestEdgeSubscription
  extends Promise<AsyncIterator<InterestEdge>>,
    Fragmentable {
  node: <T = InterestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface AggregateInstagram {
  count: Int;
}

export interface AggregateInstagramPromise
  extends Promise<AggregateInstagram>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInstagramSubscription
  extends Promise<AsyncIterator<AggregateInstagram>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FilePreviousValues {
  id: ID_Output;
  secret: String;
  url: String;
  public_id: String;
  name: String;
  size: Int;
  width?: Int;
  height?: Int;
  resource_type?: String;
  contentType: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  secret: () => Promise<String>;
  url: () => Promise<String>;
  public_id: () => Promise<String>;
  name: () => Promise<String>;
  size: () => Promise<Int>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
  resource_type: () => Promise<String>;
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  secret: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  public_id: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
  resource_type: () => Promise<AsyncIterator<String>>;
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InstagramConnection {
  pageInfo: PageInfo;
  edges: InstagramEdge[];
}

export interface InstagramConnectionPromise
  extends Promise<InstagramConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InstagramEdge>>() => T;
  aggregate: <T = AggregateInstagramPromise>() => T;
}

export interface InstagramConnectionSubscription
  extends Promise<AsyncIterator<InstagramConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InstagramEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInstagramSubscription>() => T;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface AggregateInfluencer {
  count: Int;
}

export interface AggregateInfluencerPromise
  extends Promise<AggregateInfluencer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInfluencerSubscription
  extends Promise<AsyncIterator<AggregateInfluencer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GeoSubscriptionPayload {
  mutation: MutationType;
  node: Geo;
  updatedFields: String[];
  previousValues: GeoPreviousValues;
}

export interface GeoSubscriptionPayloadPromise
  extends Promise<GeoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GeoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GeoPreviousValuesPromise>() => T;
}

export interface GeoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GeoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GeoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GeoPreviousValuesSubscription>() => T;
}

export interface InfluencerConnection {
  pageInfo: PageInfo;
  edges: InfluencerEdge[];
}

export interface InfluencerConnectionPromise
  extends Promise<InfluencerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InfluencerEdge>>() => T;
  aggregate: <T = AggregateInfluencerPromise>() => T;
}

export interface InfluencerConnectionSubscription
  extends Promise<AsyncIterator<InfluencerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InfluencerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInfluencerSubscription>() => T;
}

export interface GeoPreviousValues {
  lat?: Float;
  lng?: Float;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GeoPreviousValuesPromise
  extends Promise<GeoPreviousValues>,
    Fragmentable {
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GeoPreviousValuesSubscription
  extends Promise<AsyncIterator<GeoPreviousValues>>,
    Fragmentable {
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGeo {
  count: Int;
}

export interface AggregateGeoPromise
  extends Promise<AggregateGeo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGeoSubscription
  extends Promise<AsyncIterator<AggregateGeo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Feedback {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  comment?: String;
}

export interface FeedbackPromise extends Promise<Feedback>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  influencer: <T = InfluencerPromise>() => T;
  company: <T = CompanyPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  comment: () => Promise<String>;
}

export interface FeedbackSubscription
  extends Promise<AsyncIterator<Feedback>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  influencer: <T = InfluencerSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  comment: () => Promise<AsyncIterator<String>>;
}

export interface GeoConnection {
  pageInfo: PageInfo;
  edges: GeoEdge[];
}

export interface GeoConnectionPromise
  extends Promise<GeoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GeoEdge>>() => T;
  aggregate: <T = AggregateGeoPromise>() => T;
}

export interface GeoConnectionSubscription
  extends Promise<AsyncIterator<GeoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GeoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGeoSubscription>() => T;
}

export interface InfluencerSubscriptionPayload {
  mutation: MutationType;
  node: Influencer;
  updatedFields: String[];
  previousValues: InfluencerPreviousValues;
}

export interface InfluencerSubscriptionPayloadPromise
  extends Promise<InfluencerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InfluencerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InfluencerPreviousValuesPromise>() => T;
}

export interface InfluencerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InfluencerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InfluencerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InfluencerPreviousValuesSubscription>() => T;
}

export interface AggregateYoutube {
  count: Int;
}

export interface AggregateYoutubePromise
  extends Promise<AggregateYoutube>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateYoutubeSubscription
  extends Promise<AsyncIterator<AggregateYoutube>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InfluencerPreviousValues {
  id: ID_Output;
  email: String;
  handle?: String;
  avatar?: String;
  name?: String;
  bio?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  password: String;
  verified?: Boolean;
  specialty?: String;
}

export interface InfluencerPreviousValuesPromise
  extends Promise<InfluencerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  handle: () => Promise<String>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  verified: () => Promise<Boolean>;
  specialty: () => Promise<String>;
}

export interface InfluencerPreviousValuesSubscription
  extends Promise<AsyncIterator<InfluencerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  handle: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  specialty: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTwitter {
  count: Int;
}

export interface AggregateTwitterPromise
  extends Promise<AggregateTwitter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTwitterSubscription
  extends Promise<AsyncIterator<AggregateTwitter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Jobs {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  cost?: String;
  accepted?: Boolean;
}

export interface JobsPromise extends Promise<Jobs>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  company: <T = CompanyPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  cost: () => Promise<String>;
  accepted: () => Promise<Boolean>;
}

export interface JobsSubscription
  extends Promise<AsyncIterator<Jobs>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  company: <T = CompanySubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cost: () => Promise<AsyncIterator<String>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateSocial {
  count: Int;
}

export interface AggregateSocialPromise
  extends Promise<AggregateSocial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialSubscription
  extends Promise<AsyncIterator<AggregateSocial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstagramSubscriptionPayload {
  mutation: MutationType;
  node: Instagram;
  updatedFields: String[];
  previousValues: InstagramPreviousValues;
}

export interface InstagramSubscriptionPayloadPromise
  extends Promise<InstagramSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InstagramPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InstagramPreviousValuesPromise>() => T;
}

export interface InstagramSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InstagramSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InstagramSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InstagramPreviousValuesSubscription>() => T;
}

export interface AggregateMediaKit {
  count: Int;
}

export interface AggregateMediaKitPromise
  extends Promise<AggregateMediaKit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMediaKitSubscription
  extends Promise<AsyncIterator<AggregateMediaKit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstagramPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface InstagramPreviousValuesPromise
  extends Promise<InstagramPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  handle: () => Promise<String>;
  followers: () => Promise<Int>;
  analytics: () => Promise<Json>;
  link: () => Promise<String>;
}

export interface InstagramPreviousValuesSubscription
  extends Promise<AsyncIterator<InstagramPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  handle: () => Promise<AsyncIterator<String>>;
  followers: () => Promise<AsyncIterator<Int>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Twitter {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface TwitterPromise extends Promise<Twitter>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  analytics: () => Promise<Json>;
  followers: () => Promise<Int>;
  handle: () => Promise<String>;
  link: () => Promise<String>;
}

export interface TwitterSubscription
  extends Promise<AsyncIterator<Twitter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  followers: () => Promise<AsyncIterator<Int>>;
  handle: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface JobsEdge {
  node: Jobs;
  cursor: String;
}

export interface JobsEdgePromise extends Promise<JobsEdge>, Fragmentable {
  node: <T = JobsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobsEdgeSubscription
  extends Promise<AsyncIterator<JobsEdge>>,
    Fragmentable {
  node: <T = JobsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InterestSubscriptionPayload {
  mutation: MutationType;
  node: Interest;
  updatedFields: String[];
  previousValues: InterestPreviousValues;
}

export interface InterestSubscriptionPayloadPromise
  extends Promise<InterestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InterestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InterestPreviousValuesPromise>() => T;
}

export interface InterestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InterestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InterestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InterestPreviousValuesSubscription>() => T;
}

export interface InterestConnection {
  pageInfo: PageInfo;
  edges: InterestEdge[];
}

export interface InterestConnectionPromise
  extends Promise<InterestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InterestEdge>>() => T;
  aggregate: <T = AggregateInterestPromise>() => T;
}

export interface InterestConnectionSubscription
  extends Promise<AsyncIterator<InterestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InterestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInterestSubscription>() => T;
}

export interface InterestPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  tag?: String;
}

export interface InterestPreviousValuesPromise
  extends Promise<InterestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  tag: () => Promise<String>;
}

export interface InterestPreviousValuesSubscription
  extends Promise<AsyncIterator<InterestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  tag: () => Promise<AsyncIterator<String>>;
}

export interface Location {
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  geo: <T = GeoPromise>() => T;
  influencer: <T = InfluencerPromise>() => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  geo: <T = GeoSubscription>() => T;
  influencer: <T = InfluencerSubscription>() => T;
}

export interface Youtube {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  followers?: Int;
  analytics?: Json;
  handle?: String;
  link?: String;
}

export interface YoutubePromise extends Promise<Youtube>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  followers: () => Promise<Int>;
  analytics: () => Promise<Json>;
  handle: () => Promise<String>;
  link: () => Promise<String>;
}

export interface YoutubeSubscription
  extends Promise<AsyncIterator<Youtube>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  followers: () => Promise<AsyncIterator<Int>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  handle: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface Geo {
  lat?: Float;
  lng?: Float;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GeoPromise extends Promise<Geo>, Fragmentable {
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  id: () => Promise<ID_Output>;
  location: <T = LocationPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GeoSubscription
  extends Promise<AsyncIterator<Geo>>,
    Fragmentable {
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  location: <T = LocationSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobsSubscriptionPayload {
  mutation: MutationType;
  node: Jobs;
  updatedFields: String[];
  previousValues: JobsPreviousValues;
}

export interface JobsSubscriptionPayloadPromise
  extends Promise<JobsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobsPreviousValuesPromise>() => T;
}

export interface JobsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobsPreviousValuesSubscription>() => T;
}

export interface TwitterSubscriptionPayload {
  mutation: MutationType;
  node: Twitter;
  updatedFields: String[];
  previousValues: TwitterPreviousValues;
}

export interface TwitterSubscriptionPayloadPromise
  extends Promise<TwitterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TwitterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TwitterPreviousValuesPromise>() => T;
}

export interface TwitterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TwitterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TwitterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TwitterPreviousValuesSubscription>() => T;
}

export interface JobsPreviousValues {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  cost?: String;
  accepted?: Boolean;
}

export interface JobsPreviousValuesPromise
  extends Promise<JobsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  cost: () => Promise<String>;
  accepted: () => Promise<Boolean>;
}

export interface JobsPreviousValuesSubscription
  extends Promise<AsyncIterator<JobsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cost: () => Promise<AsyncIterator<String>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
}

export interface TwitterConnection {
  pageInfo: PageInfo;
  edges: TwitterEdge[];
}

export interface TwitterConnectionPromise
  extends Promise<TwitterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TwitterEdge>>() => T;
  aggregate: <T = AggregateTwitterPromise>() => T;
}

export interface TwitterConnectionSubscription
  extends Promise<AsyncIterator<TwitterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TwitterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTwitterSubscription>() => T;
}

export interface SocialPreviousValues {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface SocialPreviousValuesPromise
  extends Promise<SocialPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SocialPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MediaKitConnection {
  pageInfo: PageInfo;
  edges: MediaKitEdge[];
}

export interface MediaKitConnectionPromise
  extends Promise<MediaKitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MediaKitEdge>>() => T;
  aggregate: <T = AggregateMediaKitPromise>() => T;
}

export interface MediaKitConnectionSubscription
  extends Promise<AsyncIterator<MediaKitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MediaKitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMediaKitSubscription>() => T;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface AggregateInterest {
  count: Int;
}

export interface AggregateInterestPromise
  extends Promise<AggregateInterest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInterestSubscription
  extends Promise<AsyncIterator<AggregateInterest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationPreviousValues {
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface InfluencerEdge {
  node: Influencer;
  cursor: String;
}

export interface InfluencerEdgePromise
  extends Promise<InfluencerEdge>,
    Fragmentable {
  node: <T = InfluencerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InfluencerEdgeSubscription
  extends Promise<AsyncIterator<InfluencerEdge>>,
    Fragmentable {
  node: <T = InfluencerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface YoutubeConnection {
  pageInfo: PageInfo;
  edges: YoutubeEdge[];
}

export interface YoutubeConnectionPromise
  extends Promise<YoutubeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<YoutubeEdge>>() => T;
  aggregate: <T = AggregateYoutubePromise>() => T;
}

export interface YoutubeConnectionSubscription
  extends Promise<AsyncIterator<YoutubeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<YoutubeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateYoutubeSubscription>() => T;
}

export interface Social {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  instagram: <T = InstagramPromise>() => T;
  youtube: <T = YoutubePromise>() => T;
  twitter: <T = TwitterPromise>() => T;
  influencer: <T = InfluencerPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  instagram: <T = InstagramSubscription>() => T;
  youtube: <T = YoutubeSubscription>() => T;
  twitter: <T = TwitterSubscription>() => T;
  influencer: <T = InfluencerSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MediaKitPreviousValues {
  id: ID_Output;
  status: Status;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface MediaKitPreviousValuesPromise
  extends Promise<MediaKitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MediaKitPreviousValuesSubscription
  extends Promise<AsyncIterator<MediaKitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MediaKitSubscriptionPayload {
  mutation: MutationType;
  node: MediaKit;
  updatedFields: String[];
  previousValues: MediaKitPreviousValues;
}

export interface MediaKitSubscriptionPayloadPromise
  extends Promise<MediaKitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MediaKitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MediaKitPreviousValuesPromise>() => T;
}

export interface MediaKitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MediaKitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MediaKitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MediaKitPreviousValuesSubscription>() => T;
}

export interface Instagram {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  handle?: String;
  followers?: Int;
  analytics?: Json;
  link?: String;
}

export interface InstagramPromise extends Promise<Instagram>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  handle: () => Promise<String>;
  followers: () => Promise<Int>;
  analytics: () => Promise<Json>;
  link: () => Promise<String>;
}

export interface InstagramSubscription
  extends Promise<AsyncIterator<Instagram>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  handle: () => Promise<AsyncIterator<String>>;
  followers: () => Promise<AsyncIterator<Int>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface SocialConnection {
  pageInfo: PageInfo;
  edges: SocialEdge[];
}

export interface SocialConnectionPromise
  extends Promise<SocialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialEdge>>() => T;
  aggregate: <T = AggregateSocialPromise>() => T;
}

export interface SocialConnectionSubscription
  extends Promise<AsyncIterator<SocialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialSubscription>() => T;
}

export interface GeoEdge {
  node: Geo;
  cursor: String;
}

export interface GeoEdgePromise extends Promise<GeoEdge>, Fragmentable {
  node: <T = GeoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GeoEdgeSubscription
  extends Promise<AsyncIterator<GeoEdge>>,
    Fragmentable {
  node: <T = GeoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InstagramEdge {
  node: Instagram;
  cursor: String;
}

export interface InstagramEdgePromise
  extends Promise<InstagramEdge>,
    Fragmentable {
  node: <T = InstagramPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InstagramEdgeSubscription
  extends Promise<AsyncIterator<InstagramEdge>>,
    Fragmentable {
  node: <T = InstagramSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TwitterPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  analytics?: Json;
  followers?: Int;
  handle?: String;
  link?: String;
}

export interface TwitterPreviousValuesPromise
  extends Promise<TwitterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  analytics: () => Promise<Json>;
  followers: () => Promise<Int>;
  handle: () => Promise<String>;
  link: () => Promise<String>;
}

export interface TwitterPreviousValuesSubscription
  extends Promise<AsyncIterator<TwitterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  analytics: () => Promise<AsyncIterator<Json>>;
  followers: () => Promise<AsyncIterator<Int>>;
  handle: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Locale",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Geo",
    embedded: false
  },
  {
    name: "Influencer",
    embedded: false
  },
  {
    name: "MediaKit",
    embedded: false
  },
  {
    name: "Interest",
    embedded: false
  },
  {
    name: "Jobs",
    embedded: false
  },
  {
    name: "Social",
    embedded: false
  },
  {
    name: "Instagram",
    embedded: false
  },
  {
    name: "Twitter",
    embedded: false
  },
  {
    name: "Youtube",
    embedded: false
  },
  {
    name: "Feedback",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://us1.prisma.sh/kameron-a-robinson/hiii/dev`
});
export const prisma = new Prisma();
