type AggregateCompany {
  count: Int!
}

type AggregateFeedback {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateGeo {
  count: Int!
}

type AggregateInfluencer {
  count: Int!
}

type AggregateInstagram {
  count: Int!
}

type AggregateInterest {
  count: Int!
}

type AggregateJobs {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMediaKit {
  count: Int!
}

type AggregateSocial {
  count: Int!
}

type AggregateTwitter {
  count: Int!
}

type AggregateYoutube {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Company {
  id: ID!
  status: Status!
  hires: Influencer
  jobs(where: JobsWhereInput, orderBy: JobsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Jobs!]
  feedback: Feedback
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  location: Json
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateInput {
  id: ID
  status: Status
  hires: InfluencerCreateOneInput
  jobs: JobsCreateManyWithoutCompanyInput
  feedback: FeedbackCreateOneWithoutCompanyInput
  name: String
  location: Json
}

input CompanyCreateOneWithoutFeedbackInput {
  create: CompanyCreateWithoutFeedbackInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateOneWithoutJobsInput {
  create: CompanyCreateWithoutJobsInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateWithoutFeedbackInput {
  id: ID
  status: Status
  hires: InfluencerCreateOneInput
  jobs: JobsCreateManyWithoutCompanyInput
  name: String
  location: Json
}

input CompanyCreateWithoutJobsInput {
  id: ID
  status: Status
  hires: InfluencerCreateOneInput
  feedback: FeedbackCreateOneWithoutCompanyInput
  name: String
  location: Json
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  location_ASC
  location_DESC
}

type CompanyPreviousValues {
  id: ID!
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  location: Json
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
  OR: [CompanySubscriptionWhereInput!]
  NOT: [CompanySubscriptionWhereInput!]
}

input CompanyUpdateInput {
  status: Status
  hires: InfluencerUpdateOneInput
  jobs: JobsUpdateManyWithoutCompanyInput
  feedback: FeedbackUpdateOneWithoutCompanyInput
  name: String
  location: Json
}

input CompanyUpdateManyMutationInput {
  status: Status
  name: String
  location: Json
}

input CompanyUpdateOneWithoutFeedbackInput {
  create: CompanyCreateWithoutFeedbackInput
  update: CompanyUpdateWithoutFeedbackDataInput
  upsert: CompanyUpsertWithoutFeedbackInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateOneWithoutJobsInput {
  create: CompanyCreateWithoutJobsInput
  update: CompanyUpdateWithoutJobsDataInput
  upsert: CompanyUpsertWithoutJobsInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateWithoutFeedbackDataInput {
  status: Status
  hires: InfluencerUpdateOneInput
  jobs: JobsUpdateManyWithoutCompanyInput
  name: String
  location: Json
}

input CompanyUpdateWithoutJobsDataInput {
  status: Status
  hires: InfluencerUpdateOneInput
  feedback: FeedbackUpdateOneWithoutCompanyInput
  name: String
  location: Json
}

input CompanyUpsertWithoutFeedbackInput {
  update: CompanyUpdateWithoutFeedbackDataInput!
  create: CompanyCreateWithoutFeedbackInput!
}

input CompanyUpsertWithoutJobsInput {
  update: CompanyUpdateWithoutJobsDataInput!
  create: CompanyCreateWithoutJobsInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  hires: InfluencerWhereInput
  jobs_every: JobsWhereInput
  jobs_some: JobsWhereInput
  jobs_none: JobsWhereInput
  feedback: FeedbackWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

scalar DateTime

type Feedback {
  id: ID!
  status: Status!
  influencer: Influencer
  company: Company
  updatedAt: DateTime!
  createdAt: DateTime!
  comment: String
}

type FeedbackConnection {
  pageInfo: PageInfo!
  edges: [FeedbackEdge]!
  aggregate: AggregateFeedback!
}

input FeedbackCreateInput {
  id: ID
  status: Status
  influencer: InfluencerCreateOneInput
  company: CompanyCreateOneWithoutFeedbackInput
  comment: String
}

input FeedbackCreateOneWithoutCompanyInput {
  create: FeedbackCreateWithoutCompanyInput
  connect: FeedbackWhereUniqueInput
}

input FeedbackCreateWithoutCompanyInput {
  id: ID
  status: Status
  influencer: InfluencerCreateOneInput
  comment: String
}

type FeedbackEdge {
  node: Feedback!
  cursor: String!
}

enum FeedbackOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  comment_ASC
  comment_DESC
}

type FeedbackPreviousValues {
  id: ID!
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
  comment: String
}

type FeedbackSubscriptionPayload {
  mutation: MutationType!
  node: Feedback
  updatedFields: [String!]
  previousValues: FeedbackPreviousValues
}

input FeedbackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackWhereInput
  AND: [FeedbackSubscriptionWhereInput!]
  OR: [FeedbackSubscriptionWhereInput!]
  NOT: [FeedbackSubscriptionWhereInput!]
}

input FeedbackUpdateInput {
  status: Status
  influencer: InfluencerUpdateOneInput
  company: CompanyUpdateOneWithoutFeedbackInput
  comment: String
}

input FeedbackUpdateManyMutationInput {
  status: Status
  comment: String
}

input FeedbackUpdateOneWithoutCompanyInput {
  create: FeedbackCreateWithoutCompanyInput
  update: FeedbackUpdateWithoutCompanyDataInput
  upsert: FeedbackUpsertWithoutCompanyInput
  delete: Boolean
  disconnect: Boolean
  connect: FeedbackWhereUniqueInput
}

input FeedbackUpdateWithoutCompanyDataInput {
  status: Status
  influencer: InfluencerUpdateOneInput
  comment: String
}

input FeedbackUpsertWithoutCompanyInput {
  update: FeedbackUpdateWithoutCompanyDataInput!
  create: FeedbackCreateWithoutCompanyInput!
}

input FeedbackWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  influencer: InfluencerWhereInput
  company: CompanyWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  NOT: [FeedbackWhereInput!]
}

input FeedbackWhereUniqueInput {
  id: ID
}

type File {
  id: ID!
  secret: String!
  url: String!
  public_id: String!
  name: String!
  size: Int!
  width: Int
  height: Int
  resource_type: String
  contentType: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  influencer: Influencer!
  mediaKit(where: MediaKitWhereInput, orderBy: MediaKitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MediaKit!]
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  secret: String!
  url: String!
  public_id: String!
  name: String!
  size: Int!
  width: Int
  height: Int
  resource_type: String
  contentType: String!
  influencer: InfluencerCreateOneWithoutFilesInput!
  mediaKit: MediaKitCreateManyWithoutFilesInput
}

input FileCreateManyWithoutInfluencerInput {
  create: [FileCreateWithoutInfluencerInput!]
  connect: [FileWhereUniqueInput!]
}

input FileCreateManyWithoutMediaKitInput {
  create: [FileCreateWithoutMediaKitInput!]
  connect: [FileWhereUniqueInput!]
}

input FileCreateWithoutInfluencerInput {
  id: ID
  secret: String!
  url: String!
  public_id: String!
  name: String!
  size: Int!
  width: Int
  height: Int
  resource_type: String
  contentType: String!
  mediaKit: MediaKitCreateManyWithoutFilesInput
}

input FileCreateWithoutMediaKitInput {
  id: ID
  secret: String!
  url: String!
  public_id: String!
  name: String!
  size: Int!
  width: Int
  height: Int
  resource_type: String
  contentType: String!
  influencer: InfluencerCreateOneWithoutFilesInput!
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  secret_ASC
  secret_DESC
  url_ASC
  url_DESC
  public_id_ASC
  public_id_DESC
  name_ASC
  name_DESC
  size_ASC
  size_DESC
  width_ASC
  width_DESC
  height_ASC
  height_DESC
  resource_type_ASC
  resource_type_DESC
  contentType_ASC
  contentType_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FilePreviousValues {
  id: ID!
  secret: String!
  url: String!
  public_id: String!
  name: String!
  size: Int!
  width: Int
  height: Int
  resource_type: String
  contentType: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  secret: String
  secret_not: String
  secret_in: [String!]
  secret_not_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_gt: String
  secret_gte: String
  secret_contains: String
  secret_not_contains: String
  secret_starts_with: String
  secret_not_starts_with: String
  secret_ends_with: String
  secret_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  public_id: String
  public_id_not: String
  public_id_in: [String!]
  public_id_not_in: [String!]
  public_id_lt: String
  public_id_lte: String
  public_id_gt: String
  public_id_gte: String
  public_id_contains: String
  public_id_not_contains: String
  public_id_starts_with: String
  public_id_not_starts_with: String
  public_id_ends_with: String
  public_id_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  size: Int
  size_not: Int
  size_in: [Int!]
  size_not_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_gt: Int
  size_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  resource_type: String
  resource_type_not: String
  resource_type_in: [String!]
  resource_type_not_in: [String!]
  resource_type_lt: String
  resource_type_lte: String
  resource_type_gt: String
  resource_type_gte: String
  resource_type_contains: String
  resource_type_not_contains: String
  resource_type_starts_with: String
  resource_type_not_starts_with: String
  resource_type_ends_with: String
  resource_type_not_ends_with: String
  contentType: String
  contentType_not: String
  contentType_in: [String!]
  contentType_not_in: [String!]
  contentType_lt: String
  contentType_lte: String
  contentType_gt: String
  contentType_gte: String
  contentType_contains: String
  contentType_not_contains: String
  contentType_starts_with: String
  contentType_not_starts_with: String
  contentType_ends_with: String
  contentType_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FileScalarWhereInput!]
  OR: [FileScalarWhereInput!]
  NOT: [FileScalarWhereInput!]
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateInput {
  secret: String
  url: String
  public_id: String
  name: String
  size: Int
  width: Int
  height: Int
  resource_type: String
  contentType: String
  influencer: InfluencerUpdateOneRequiredWithoutFilesInput
  mediaKit: MediaKitUpdateManyWithoutFilesInput
}

input FileUpdateManyDataInput {
  secret: String
  url: String
  public_id: String
  name: String
  size: Int
  width: Int
  height: Int
  resource_type: String
  contentType: String
}

input FileUpdateManyMutationInput {
  secret: String
  url: String
  public_id: String
  name: String
  size: Int
  width: Int
  height: Int
  resource_type: String
  contentType: String
}

input FileUpdateManyWithoutInfluencerInput {
  create: [FileCreateWithoutInfluencerInput!]
  delete: [FileWhereUniqueInput!]
  connect: [FileWhereUniqueInput!]
  set: [FileWhereUniqueInput!]
  disconnect: [FileWhereUniqueInput!]
  update: [FileUpdateWithWhereUniqueWithoutInfluencerInput!]
  upsert: [FileUpsertWithWhereUniqueWithoutInfluencerInput!]
  deleteMany: [FileScalarWhereInput!]
  updateMany: [FileUpdateManyWithWhereNestedInput!]
}

input FileUpdateManyWithoutMediaKitInput {
  create: [FileCreateWithoutMediaKitInput!]
  delete: [FileWhereUniqueInput!]
  connect: [FileWhereUniqueInput!]
  set: [FileWhereUniqueInput!]
  disconnect: [FileWhereUniqueInput!]
  update: [FileUpdateWithWhereUniqueWithoutMediaKitInput!]
  upsert: [FileUpsertWithWhereUniqueWithoutMediaKitInput!]
  deleteMany: [FileScalarWhereInput!]
  updateMany: [FileUpdateManyWithWhereNestedInput!]
}

input FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput!
  data: FileUpdateManyDataInput!
}

input FileUpdateWithoutInfluencerDataInput {
  secret: String
  url: String
  public_id: String
  name: String
  size: Int
  width: Int
  height: Int
  resource_type: String
  contentType: String
  mediaKit: MediaKitUpdateManyWithoutFilesInput
}

input FileUpdateWithoutMediaKitDataInput {
  secret: String
  url: String
  public_id: String
  name: String
  size: Int
  width: Int
  height: Int
  resource_type: String
  contentType: String
  influencer: InfluencerUpdateOneRequiredWithoutFilesInput
}

input FileUpdateWithWhereUniqueWithoutInfluencerInput {
  where: FileWhereUniqueInput!
  data: FileUpdateWithoutInfluencerDataInput!
}

input FileUpdateWithWhereUniqueWithoutMediaKitInput {
  where: FileWhereUniqueInput!
  data: FileUpdateWithoutMediaKitDataInput!
}

input FileUpsertWithWhereUniqueWithoutInfluencerInput {
  where: FileWhereUniqueInput!
  update: FileUpdateWithoutInfluencerDataInput!
  create: FileCreateWithoutInfluencerInput!
}

input FileUpsertWithWhereUniqueWithoutMediaKitInput {
  where: FileWhereUniqueInput!
  update: FileUpdateWithoutMediaKitDataInput!
  create: FileCreateWithoutMediaKitInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  secret: String
  secret_not: String
  secret_in: [String!]
  secret_not_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_gt: String
  secret_gte: String
  secret_contains: String
  secret_not_contains: String
  secret_starts_with: String
  secret_not_starts_with: String
  secret_ends_with: String
  secret_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  public_id: String
  public_id_not: String
  public_id_in: [String!]
  public_id_not_in: [String!]
  public_id_lt: String
  public_id_lte: String
  public_id_gt: String
  public_id_gte: String
  public_id_contains: String
  public_id_not_contains: String
  public_id_starts_with: String
  public_id_not_starts_with: String
  public_id_ends_with: String
  public_id_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  size: Int
  size_not: Int
  size_in: [Int!]
  size_not_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_gt: Int
  size_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  resource_type: String
  resource_type_not: String
  resource_type_in: [String!]
  resource_type_not_in: [String!]
  resource_type_lt: String
  resource_type_lte: String
  resource_type_gt: String
  resource_type_gte: String
  resource_type_contains: String
  resource_type_not_contains: String
  resource_type_starts_with: String
  resource_type_not_starts_with: String
  resource_type_ends_with: String
  resource_type_not_ends_with: String
  contentType: String
  contentType_not: String
  contentType_in: [String!]
  contentType_not_in: [String!]
  contentType_lt: String
  contentType_lte: String
  contentType_gt: String
  contentType_gte: String
  contentType_contains: String
  contentType_not_contains: String
  contentType_starts_with: String
  contentType_not_starts_with: String
  contentType_ends_with: String
  contentType_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  influencer: InfluencerWhereInput
  mediaKit_every: MediaKitWhereInput
  mediaKit_some: MediaKitWhereInput
  mediaKit_none: MediaKitWhereInput
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  secret: String
  url: String
}

type Geo {
  lat: Float
  lng: Float
  id: ID!
  location: Location
  updatedAt: DateTime!
  createdAt: DateTime!
}

type GeoConnection {
  pageInfo: PageInfo!
  edges: [GeoEdge]!
  aggregate: AggregateGeo!
}

input GeoCreateInput {
  lat: Float
  lng: Float
  id: ID
  location: LocationCreateOneWithoutGeoInput
}

input GeoCreateOneWithoutLocationInput {
  create: GeoCreateWithoutLocationInput
  connect: GeoWhereUniqueInput
}

input GeoCreateWithoutLocationInput {
  lat: Float
  lng: Float
  id: ID
}

type GeoEdge {
  node: Geo!
  cursor: String!
}

enum GeoOrderByInput {
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type GeoPreviousValues {
  lat: Float
  lng: Float
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type GeoSubscriptionPayload {
  mutation: MutationType!
  node: Geo
  updatedFields: [String!]
  previousValues: GeoPreviousValues
}

input GeoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GeoWhereInput
  AND: [GeoSubscriptionWhereInput!]
  OR: [GeoSubscriptionWhereInput!]
  NOT: [GeoSubscriptionWhereInput!]
}

input GeoUpdateInput {
  lat: Float
  lng: Float
  location: LocationUpdateOneWithoutGeoInput
}

input GeoUpdateManyMutationInput {
  lat: Float
  lng: Float
}

input GeoUpdateOneWithoutLocationInput {
  create: GeoCreateWithoutLocationInput
  update: GeoUpdateWithoutLocationDataInput
  upsert: GeoUpsertWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  connect: GeoWhereUniqueInput
}

input GeoUpdateWithoutLocationDataInput {
  lat: Float
  lng: Float
}

input GeoUpsertWithoutLocationInput {
  update: GeoUpdateWithoutLocationDataInput!
  create: GeoCreateWithoutLocationInput!
}

input GeoWhereInput {
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: LocationWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [GeoWhereInput!]
  OR: [GeoWhereInput!]
  NOT: [GeoWhereInput!]
}

input GeoWhereUniqueInput {
  id: ID
}

type Influencer {
  id: ID!
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  updatedAt: DateTime!
  createdAt: DateTime!
  password: String!
  verified: Boolean
  specialty: String
  location: Location
  mediaKit(where: MediaKitWhereInput, orderBy: MediaKitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MediaKit!]
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File!]
  social: Social
}

type InfluencerConnection {
  pageInfo: PageInfo!
  edges: [InfluencerEdge]!
  aggregate: AggregateInfluencer!
}

input InfluencerCreateInput {
  id: ID
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  password: String!
  verified: Boolean
  specialty: String
  location: LocationCreateOneWithoutInfluencerInput
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  files: FileCreateManyWithoutInfluencerInput
  social: SocialCreateOneWithoutInfluencerInput
}

input InfluencerCreateOneInput {
  create: InfluencerCreateInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerCreateOneWithoutFilesInput {
  create: InfluencerCreateWithoutFilesInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerCreateOneWithoutLocationInput {
  create: InfluencerCreateWithoutLocationInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerCreateOneWithoutMediaKitInput {
  create: InfluencerCreateWithoutMediaKitInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerCreateOneWithoutSocialInput {
  create: InfluencerCreateWithoutSocialInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerCreateWithoutFilesInput {
  id: ID
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  password: String!
  verified: Boolean
  specialty: String
  location: LocationCreateOneWithoutInfluencerInput
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  social: SocialCreateOneWithoutInfluencerInput
}

input InfluencerCreateWithoutLocationInput {
  id: ID
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  password: String!
  verified: Boolean
  specialty: String
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  files: FileCreateManyWithoutInfluencerInput
  social: SocialCreateOneWithoutInfluencerInput
}

input InfluencerCreateWithoutMediaKitInput {
  id: ID
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  password: String!
  verified: Boolean
  specialty: String
  location: LocationCreateOneWithoutInfluencerInput
  files: FileCreateManyWithoutInfluencerInput
  social: SocialCreateOneWithoutInfluencerInput
}

input InfluencerCreateWithoutSocialInput {
  id: ID
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  password: String!
  verified: Boolean
  specialty: String
  location: LocationCreateOneWithoutInfluencerInput
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  files: FileCreateManyWithoutInfluencerInput
}

type InfluencerEdge {
  node: Influencer!
  cursor: String!
}

enum InfluencerOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  handle_ASC
  handle_DESC
  avatar_ASC
  avatar_DESC
  name_ASC
  name_DESC
  bio_ASC
  bio_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  password_ASC
  password_DESC
  verified_ASC
  verified_DESC
  specialty_ASC
  specialty_DESC
}

type InfluencerPreviousValues {
  id: ID!
  email: String!
  handle: String
  avatar: String
  name: String
  bio: String
  updatedAt: DateTime!
  createdAt: DateTime!
  password: String!
  verified: Boolean
  specialty: String
}

type InfluencerSubscriptionPayload {
  mutation: MutationType!
  node: Influencer
  updatedFields: [String!]
  previousValues: InfluencerPreviousValues
}

input InfluencerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InfluencerWhereInput
  AND: [InfluencerSubscriptionWhereInput!]
  OR: [InfluencerSubscriptionWhereInput!]
  NOT: [InfluencerSubscriptionWhereInput!]
}

input InfluencerUpdateDataInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  files: FileUpdateManyWithoutInfluencerInput
  social: SocialUpdateOneWithoutInfluencerInput
}

input InfluencerUpdateInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  files: FileUpdateManyWithoutInfluencerInput
  social: SocialUpdateOneWithoutInfluencerInput
}

input InfluencerUpdateManyMutationInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
}

input InfluencerUpdateOneInput {
  create: InfluencerCreateInput
  update: InfluencerUpdateDataInput
  upsert: InfluencerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InfluencerWhereUniqueInput
}

input InfluencerUpdateOneRequiredWithoutFilesInput {
  create: InfluencerCreateWithoutFilesInput
  update: InfluencerUpdateWithoutFilesDataInput
  upsert: InfluencerUpsertWithoutFilesInput
  connect: InfluencerWhereUniqueInput
}

input InfluencerUpdateOneWithoutLocationInput {
  create: InfluencerCreateWithoutLocationInput
  update: InfluencerUpdateWithoutLocationDataInput
  upsert: InfluencerUpsertWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  connect: InfluencerWhereUniqueInput
}

input InfluencerUpdateOneWithoutMediaKitInput {
  create: InfluencerCreateWithoutMediaKitInput
  update: InfluencerUpdateWithoutMediaKitDataInput
  upsert: InfluencerUpsertWithoutMediaKitInput
  delete: Boolean
  disconnect: Boolean
  connect: InfluencerWhereUniqueInput
}

input InfluencerUpdateOneWithoutSocialInput {
  create: InfluencerCreateWithoutSocialInput
  update: InfluencerUpdateWithoutSocialDataInput
  upsert: InfluencerUpsertWithoutSocialInput
  delete: Boolean
  disconnect: Boolean
  connect: InfluencerWhereUniqueInput
}

input InfluencerUpdateWithoutFilesDataInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  social: SocialUpdateOneWithoutInfluencerInput
}

input InfluencerUpdateWithoutLocationDataInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  files: FileUpdateManyWithoutInfluencerInput
  social: SocialUpdateOneWithoutInfluencerInput
}

input InfluencerUpdateWithoutMediaKitDataInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  location: LocationUpdateOneWithoutInfluencerInput
  files: FileUpdateManyWithoutInfluencerInput
  social: SocialUpdateOneWithoutInfluencerInput
}

input InfluencerUpdateWithoutSocialDataInput {
  email: String
  handle: String
  avatar: String
  name: String
  bio: String
  password: String
  verified: Boolean
  specialty: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  files: FileUpdateManyWithoutInfluencerInput
}

input InfluencerUpsertNestedInput {
  update: InfluencerUpdateDataInput!
  create: InfluencerCreateInput!
}

input InfluencerUpsertWithoutFilesInput {
  update: InfluencerUpdateWithoutFilesDataInput!
  create: InfluencerCreateWithoutFilesInput!
}

input InfluencerUpsertWithoutLocationInput {
  update: InfluencerUpdateWithoutLocationDataInput!
  create: InfluencerCreateWithoutLocationInput!
}

input InfluencerUpsertWithoutMediaKitInput {
  update: InfluencerUpdateWithoutMediaKitDataInput!
  create: InfluencerCreateWithoutMediaKitInput!
}

input InfluencerUpsertWithoutSocialInput {
  update: InfluencerUpdateWithoutSocialDataInput!
  create: InfluencerCreateWithoutSocialInput!
}

input InfluencerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  verified: Boolean
  verified_not: Boolean
  specialty: String
  specialty_not: String
  specialty_in: [String!]
  specialty_not_in: [String!]
  specialty_lt: String
  specialty_lte: String
  specialty_gt: String
  specialty_gte: String
  specialty_contains: String
  specialty_not_contains: String
  specialty_starts_with: String
  specialty_not_starts_with: String
  specialty_ends_with: String
  specialty_not_ends_with: String
  location: LocationWhereInput
  mediaKit_every: MediaKitWhereInput
  mediaKit_some: MediaKitWhereInput
  mediaKit_none: MediaKitWhereInput
  files_every: FileWhereInput
  files_some: FileWhereInput
  files_none: FileWhereInput
  social: SocialWhereInput
  AND: [InfluencerWhereInput!]
  OR: [InfluencerWhereInput!]
  NOT: [InfluencerWhereInput!]
}

input InfluencerWhereUniqueInput {
  id: ID
  email: String
  handle: String
}

type Instagram {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  handle: String
  followers: Int
  analytics: Json
  link: String
}

type InstagramConnection {
  pageInfo: PageInfo!
  edges: [InstagramEdge]!
  aggregate: AggregateInstagram!
}

input InstagramCreateInput {
  id: ID
  handle: String
  followers: Int
  analytics: Json
  link: String
}

input InstagramCreateOneInput {
  create: InstagramCreateInput
  connect: InstagramWhereUniqueInput
}

type InstagramEdge {
  node: Instagram!
  cursor: String!
}

enum InstagramOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  handle_ASC
  handle_DESC
  followers_ASC
  followers_DESC
  analytics_ASC
  analytics_DESC
  link_ASC
  link_DESC
}

type InstagramPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  handle: String
  followers: Int
  analytics: Json
  link: String
}

type InstagramSubscriptionPayload {
  mutation: MutationType!
  node: Instagram
  updatedFields: [String!]
  previousValues: InstagramPreviousValues
}

input InstagramSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InstagramWhereInput
  AND: [InstagramSubscriptionWhereInput!]
  OR: [InstagramSubscriptionWhereInput!]
  NOT: [InstagramSubscriptionWhereInput!]
}

input InstagramUpdateDataInput {
  handle: String
  followers: Int
  analytics: Json
  link: String
}

input InstagramUpdateInput {
  handle: String
  followers: Int
  analytics: Json
  link: String
}

input InstagramUpdateManyMutationInput {
  handle: String
  followers: Int
  analytics: Json
  link: String
}

input InstagramUpdateOneInput {
  create: InstagramCreateInput
  update: InstagramUpdateDataInput
  upsert: InstagramUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InstagramWhereUniqueInput
}

input InstagramUpsertNestedInput {
  update: InstagramUpdateDataInput!
  create: InstagramCreateInput!
}

input InstagramWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  followers: Int
  followers_not: Int
  followers_in: [Int!]
  followers_not_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_gt: Int
  followers_gte: Int
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [InstagramWhereInput!]
  OR: [InstagramWhereInput!]
  NOT: [InstagramWhereInput!]
}

input InstagramWhereUniqueInput {
  id: ID
}

type Interest {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  tag: String
  influencer: Influencer
}

type InterestConnection {
  pageInfo: PageInfo!
  edges: [InterestEdge]!
  aggregate: AggregateInterest!
}

input InterestCreateInput {
  id: ID
  tag: String
  influencer: InfluencerCreateOneInput
}

input InterestCreateManyInput {
  create: [InterestCreateInput!]
  connect: [InterestWhereUniqueInput!]
}

type InterestEdge {
  node: Interest!
  cursor: String!
}

enum InterestOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  tag_ASC
  tag_DESC
}

type InterestPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  tag: String
}

input InterestScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  tag: String
  tag_not: String
  tag_in: [String!]
  tag_not_in: [String!]
  tag_lt: String
  tag_lte: String
  tag_gt: String
  tag_gte: String
  tag_contains: String
  tag_not_contains: String
  tag_starts_with: String
  tag_not_starts_with: String
  tag_ends_with: String
  tag_not_ends_with: String
  AND: [InterestScalarWhereInput!]
  OR: [InterestScalarWhereInput!]
  NOT: [InterestScalarWhereInput!]
}

type InterestSubscriptionPayload {
  mutation: MutationType!
  node: Interest
  updatedFields: [String!]
  previousValues: InterestPreviousValues
}

input InterestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InterestWhereInput
  AND: [InterestSubscriptionWhereInput!]
  OR: [InterestSubscriptionWhereInput!]
  NOT: [InterestSubscriptionWhereInput!]
}

input InterestUpdateDataInput {
  tag: String
  influencer: InfluencerUpdateOneInput
}

input InterestUpdateInput {
  tag: String
  influencer: InfluencerUpdateOneInput
}

input InterestUpdateManyDataInput {
  tag: String
}

input InterestUpdateManyInput {
  create: [InterestCreateInput!]
  update: [InterestUpdateWithWhereUniqueNestedInput!]
  upsert: [InterestUpsertWithWhereUniqueNestedInput!]
  delete: [InterestWhereUniqueInput!]
  connect: [InterestWhereUniqueInput!]
  set: [InterestWhereUniqueInput!]
  disconnect: [InterestWhereUniqueInput!]
  deleteMany: [InterestScalarWhereInput!]
  updateMany: [InterestUpdateManyWithWhereNestedInput!]
}

input InterestUpdateManyMutationInput {
  tag: String
}

input InterestUpdateManyWithWhereNestedInput {
  where: InterestScalarWhereInput!
  data: InterestUpdateManyDataInput!
}

input InterestUpdateWithWhereUniqueNestedInput {
  where: InterestWhereUniqueInput!
  data: InterestUpdateDataInput!
}

input InterestUpsertWithWhereUniqueNestedInput {
  where: InterestWhereUniqueInput!
  update: InterestUpdateDataInput!
  create: InterestCreateInput!
}

input InterestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  tag: String
  tag_not: String
  tag_in: [String!]
  tag_not_in: [String!]
  tag_lt: String
  tag_lte: String
  tag_gt: String
  tag_gte: String
  tag_contains: String
  tag_not_contains: String
  tag_starts_with: String
  tag_not_starts_with: String
  tag_ends_with: String
  tag_not_ends_with: String
  influencer: InfluencerWhereInput
  AND: [InterestWhereInput!]
  OR: [InterestWhereInput!]
  NOT: [InterestWhereInput!]
}

input InterestWhereUniqueInput {
  id: ID
}

type Jobs {
  id: ID!
  status: Status!
  company: Company
  updatedAt: DateTime!
  createdAt: DateTime!
  cost: String
  accepted: Boolean
}

type JobsConnection {
  pageInfo: PageInfo!
  edges: [JobsEdge]!
  aggregate: AggregateJobs!
}

input JobsCreateInput {
  id: ID
  status: Status
  company: CompanyCreateOneWithoutJobsInput
  cost: String
  accepted: Boolean
}

input JobsCreateManyWithoutCompanyInput {
  create: [JobsCreateWithoutCompanyInput!]
  connect: [JobsWhereUniqueInput!]
}

input JobsCreateWithoutCompanyInput {
  id: ID
  status: Status
  cost: String
  accepted: Boolean
}

type JobsEdge {
  node: Jobs!
  cursor: String!
}

enum JobsOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  cost_ASC
  cost_DESC
  accepted_ASC
  accepted_DESC
}

type JobsPreviousValues {
  id: ID!
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
  cost: String
  accepted: Boolean
}

input JobsScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  cost: String
  cost_not: String
  cost_in: [String!]
  cost_not_in: [String!]
  cost_lt: String
  cost_lte: String
  cost_gt: String
  cost_gte: String
  cost_contains: String
  cost_not_contains: String
  cost_starts_with: String
  cost_not_starts_with: String
  cost_ends_with: String
  cost_not_ends_with: String
  accepted: Boolean
  accepted_not: Boolean
  AND: [JobsScalarWhereInput!]
  OR: [JobsScalarWhereInput!]
  NOT: [JobsScalarWhereInput!]
}

type JobsSubscriptionPayload {
  mutation: MutationType!
  node: Jobs
  updatedFields: [String!]
  previousValues: JobsPreviousValues
}

input JobsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JobsWhereInput
  AND: [JobsSubscriptionWhereInput!]
  OR: [JobsSubscriptionWhereInput!]
  NOT: [JobsSubscriptionWhereInput!]
}

input JobsUpdateInput {
  status: Status
  company: CompanyUpdateOneWithoutJobsInput
  cost: String
  accepted: Boolean
}

input JobsUpdateManyDataInput {
  status: Status
  cost: String
  accepted: Boolean
}

input JobsUpdateManyMutationInput {
  status: Status
  cost: String
  accepted: Boolean
}

input JobsUpdateManyWithoutCompanyInput {
  create: [JobsCreateWithoutCompanyInput!]
  delete: [JobsWhereUniqueInput!]
  connect: [JobsWhereUniqueInput!]
  set: [JobsWhereUniqueInput!]
  disconnect: [JobsWhereUniqueInput!]
  update: [JobsUpdateWithWhereUniqueWithoutCompanyInput!]
  upsert: [JobsUpsertWithWhereUniqueWithoutCompanyInput!]
  deleteMany: [JobsScalarWhereInput!]
  updateMany: [JobsUpdateManyWithWhereNestedInput!]
}

input JobsUpdateManyWithWhereNestedInput {
  where: JobsScalarWhereInput!
  data: JobsUpdateManyDataInput!
}

input JobsUpdateWithoutCompanyDataInput {
  status: Status
  cost: String
  accepted: Boolean
}

input JobsUpdateWithWhereUniqueWithoutCompanyInput {
  where: JobsWhereUniqueInput!
  data: JobsUpdateWithoutCompanyDataInput!
}

input JobsUpsertWithWhereUniqueWithoutCompanyInput {
  where: JobsWhereUniqueInput!
  update: JobsUpdateWithoutCompanyDataInput!
  create: JobsCreateWithoutCompanyInput!
}

input JobsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  company: CompanyWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  cost: String
  cost_not: String
  cost_in: [String!]
  cost_not_in: [String!]
  cost_lt: String
  cost_lte: String
  cost_gt: String
  cost_gte: String
  cost_contains: String
  cost_not_contains: String
  cost_starts_with: String
  cost_not_starts_with: String
  cost_ends_with: String
  cost_not_ends_with: String
  accepted: Boolean
  accepted_not: Boolean
  AND: [JobsWhereInput!]
  OR: [JobsWhereInput!]
  NOT: [JobsWhereInput!]
}

input JobsWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  updatedAt: DateTime!
  createdAt: DateTime!
  id: ID!
  name: String
  geo: Geo
  influencer: Influencer
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  name: String
  geo: GeoCreateOneWithoutLocationInput
  influencer: InfluencerCreateOneWithoutLocationInput
}

input LocationCreateOneWithoutGeoInput {
  create: LocationCreateWithoutGeoInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutInfluencerInput {
  create: LocationCreateWithoutInfluencerInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutGeoInput {
  id: ID
  name: String
  influencer: InfluencerCreateOneWithoutLocationInput
}

input LocationCreateWithoutInfluencerInput {
  id: ID
  name: String
  geo: GeoCreateOneWithoutLocationInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type LocationPreviousValues {
  updatedAt: DateTime!
  createdAt: DateTime!
  id: ID!
  name: String
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateInput {
  name: String
  geo: GeoUpdateOneWithoutLocationInput
  influencer: InfluencerUpdateOneWithoutLocationInput
}

input LocationUpdateManyMutationInput {
  name: String
}

input LocationUpdateOneWithoutGeoInput {
  create: LocationCreateWithoutGeoInput
  update: LocationUpdateWithoutGeoDataInput
  upsert: LocationUpsertWithoutGeoInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneWithoutInfluencerInput {
  create: LocationCreateWithoutInfluencerInput
  update: LocationUpdateWithoutInfluencerDataInput
  upsert: LocationUpsertWithoutInfluencerInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutGeoDataInput {
  name: String
  influencer: InfluencerUpdateOneWithoutLocationInput
}

input LocationUpdateWithoutInfluencerDataInput {
  name: String
  geo: GeoUpdateOneWithoutLocationInput
}

input LocationUpsertWithoutGeoInput {
  update: LocationUpdateWithoutGeoDataInput!
  create: LocationCreateWithoutGeoInput!
}

input LocationUpsertWithoutInfluencerInput {
  update: LocationUpdateWithoutInfluencerDataInput!
  create: LocationCreateWithoutInfluencerInput!
}

input LocationWhereInput {
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  geo: GeoWhereInput
  influencer: InfluencerWhereInput
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type MediaKit {
  id: ID!
  influencer: Influencer
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File!]
  interests(where: InterestWhereInput, orderBy: InterestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interest!]
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type MediaKitConnection {
  pageInfo: PageInfo!
  edges: [MediaKitEdge]!
  aggregate: AggregateMediaKit!
}

input MediaKitCreateInput {
  id: ID
  influencer: InfluencerCreateOneWithoutMediaKitInput
  files: FileCreateManyWithoutMediaKitInput
  interests: InterestCreateManyInput
  status: Status
}

input MediaKitCreateManyWithoutFilesInput {
  create: [MediaKitCreateWithoutFilesInput!]
  connect: [MediaKitWhereUniqueInput!]
}

input MediaKitCreateManyWithoutInfluencerInput {
  create: [MediaKitCreateWithoutInfluencerInput!]
  connect: [MediaKitWhereUniqueInput!]
}

input MediaKitCreateWithoutFilesInput {
  id: ID
  influencer: InfluencerCreateOneWithoutMediaKitInput
  interests: InterestCreateManyInput
  status: Status
}

input MediaKitCreateWithoutInfluencerInput {
  id: ID
  files: FileCreateManyWithoutMediaKitInput
  interests: InterestCreateManyInput
  status: Status
}

type MediaKitEdge {
  node: MediaKit!
  cursor: String!
}

enum MediaKitOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MediaKitPreviousValues {
  id: ID!
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input MediaKitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MediaKitScalarWhereInput!]
  OR: [MediaKitScalarWhereInput!]
  NOT: [MediaKitScalarWhereInput!]
}

type MediaKitSubscriptionPayload {
  mutation: MutationType!
  node: MediaKit
  updatedFields: [String!]
  previousValues: MediaKitPreviousValues
}

input MediaKitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MediaKitWhereInput
  AND: [MediaKitSubscriptionWhereInput!]
  OR: [MediaKitSubscriptionWhereInput!]
  NOT: [MediaKitSubscriptionWhereInput!]
}

input MediaKitUpdateInput {
  influencer: InfluencerUpdateOneWithoutMediaKitInput
  files: FileUpdateManyWithoutMediaKitInput
  interests: InterestUpdateManyInput
  status: Status
}

input MediaKitUpdateManyDataInput {
  status: Status
}

input MediaKitUpdateManyMutationInput {
  status: Status
}

input MediaKitUpdateManyWithoutFilesInput {
  create: [MediaKitCreateWithoutFilesInput!]
  delete: [MediaKitWhereUniqueInput!]
  connect: [MediaKitWhereUniqueInput!]
  set: [MediaKitWhereUniqueInput!]
  disconnect: [MediaKitWhereUniqueInput!]
  update: [MediaKitUpdateWithWhereUniqueWithoutFilesInput!]
  upsert: [MediaKitUpsertWithWhereUniqueWithoutFilesInput!]
  deleteMany: [MediaKitScalarWhereInput!]
  updateMany: [MediaKitUpdateManyWithWhereNestedInput!]
}

input MediaKitUpdateManyWithoutInfluencerInput {
  create: [MediaKitCreateWithoutInfluencerInput!]
  delete: [MediaKitWhereUniqueInput!]
  connect: [MediaKitWhereUniqueInput!]
  set: [MediaKitWhereUniqueInput!]
  disconnect: [MediaKitWhereUniqueInput!]
  update: [MediaKitUpdateWithWhereUniqueWithoutInfluencerInput!]
  upsert: [MediaKitUpsertWithWhereUniqueWithoutInfluencerInput!]
  deleteMany: [MediaKitScalarWhereInput!]
  updateMany: [MediaKitUpdateManyWithWhereNestedInput!]
}

input MediaKitUpdateManyWithWhereNestedInput {
  where: MediaKitScalarWhereInput!
  data: MediaKitUpdateManyDataInput!
}

input MediaKitUpdateWithoutFilesDataInput {
  influencer: InfluencerUpdateOneWithoutMediaKitInput
  interests: InterestUpdateManyInput
  status: Status
}

input MediaKitUpdateWithoutInfluencerDataInput {
  files: FileUpdateManyWithoutMediaKitInput
  interests: InterestUpdateManyInput
  status: Status
}

input MediaKitUpdateWithWhereUniqueWithoutFilesInput {
  where: MediaKitWhereUniqueInput!
  data: MediaKitUpdateWithoutFilesDataInput!
}

input MediaKitUpdateWithWhereUniqueWithoutInfluencerInput {
  where: MediaKitWhereUniqueInput!
  data: MediaKitUpdateWithoutInfluencerDataInput!
}

input MediaKitUpsertWithWhereUniqueWithoutFilesInput {
  where: MediaKitWhereUniqueInput!
  update: MediaKitUpdateWithoutFilesDataInput!
  create: MediaKitCreateWithoutFilesInput!
}

input MediaKitUpsertWithWhereUniqueWithoutInfluencerInput {
  where: MediaKitWhereUniqueInput!
  update: MediaKitUpdateWithoutInfluencerDataInput!
  create: MediaKitCreateWithoutInfluencerInput!
}

input MediaKitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  influencer: InfluencerWhereInput
  files_every: FileWhereInput
  files_some: FileWhereInput
  files_none: FileWhereInput
  interests_every: InterestWhereInput
  interests_some: InterestWhereInput
  interests_none: InterestWhereInput
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MediaKitWhereInput!]
  OR: [MediaKitWhereInput!]
  NOT: [MediaKitWhereInput!]
}

input MediaKitWhereUniqueInput {
  id: ID
}

type Mutation {
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createFeedback(data: FeedbackCreateInput!): Feedback!
  updateFeedback(data: FeedbackUpdateInput!, where: FeedbackWhereUniqueInput!): Feedback
  updateManyFeedbacks(data: FeedbackUpdateManyMutationInput!, where: FeedbackWhereInput): BatchPayload!
  upsertFeedback(where: FeedbackWhereUniqueInput!, create: FeedbackCreateInput!, update: FeedbackUpdateInput!): Feedback!
  deleteFeedback(where: FeedbackWhereUniqueInput!): Feedback
  deleteManyFeedbacks(where: FeedbackWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createGeo(data: GeoCreateInput!): Geo!
  updateGeo(data: GeoUpdateInput!, where: GeoWhereUniqueInput!): Geo
  updateManyGeos(data: GeoUpdateManyMutationInput!, where: GeoWhereInput): BatchPayload!
  upsertGeo(where: GeoWhereUniqueInput!, create: GeoCreateInput!, update: GeoUpdateInput!): Geo!
  deleteGeo(where: GeoWhereUniqueInput!): Geo
  deleteManyGeos(where: GeoWhereInput): BatchPayload!
  createInfluencer(data: InfluencerCreateInput!): Influencer!
  updateInfluencer(data: InfluencerUpdateInput!, where: InfluencerWhereUniqueInput!): Influencer
  updateManyInfluencers(data: InfluencerUpdateManyMutationInput!, where: InfluencerWhereInput): BatchPayload!
  upsertInfluencer(where: InfluencerWhereUniqueInput!, create: InfluencerCreateInput!, update: InfluencerUpdateInput!): Influencer!
  deleteInfluencer(where: InfluencerWhereUniqueInput!): Influencer
  deleteManyInfluencers(where: InfluencerWhereInput): BatchPayload!
  createInstagram(data: InstagramCreateInput!): Instagram!
  updateInstagram(data: InstagramUpdateInput!, where: InstagramWhereUniqueInput!): Instagram
  updateManyInstagrams(data: InstagramUpdateManyMutationInput!, where: InstagramWhereInput): BatchPayload!
  upsertInstagram(where: InstagramWhereUniqueInput!, create: InstagramCreateInput!, update: InstagramUpdateInput!): Instagram!
  deleteInstagram(where: InstagramWhereUniqueInput!): Instagram
  deleteManyInstagrams(where: InstagramWhereInput): BatchPayload!
  createInterest(data: InterestCreateInput!): Interest!
  updateInterest(data: InterestUpdateInput!, where: InterestWhereUniqueInput!): Interest
  updateManyInterests(data: InterestUpdateManyMutationInput!, where: InterestWhereInput): BatchPayload!
  upsertInterest(where: InterestWhereUniqueInput!, create: InterestCreateInput!, update: InterestUpdateInput!): Interest!
  deleteInterest(where: InterestWhereUniqueInput!): Interest
  deleteManyInterests(where: InterestWhereInput): BatchPayload!
  createJobs(data: JobsCreateInput!): Jobs!
  updateJobs(data: JobsUpdateInput!, where: JobsWhereUniqueInput!): Jobs
  updateManyJobses(data: JobsUpdateManyMutationInput!, where: JobsWhereInput): BatchPayload!
  upsertJobs(where: JobsWhereUniqueInput!, create: JobsCreateInput!, update: JobsUpdateInput!): Jobs!
  deleteJobs(where: JobsWhereUniqueInput!): Jobs
  deleteManyJobses(where: JobsWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMediaKit(data: MediaKitCreateInput!): MediaKit!
  updateMediaKit(data: MediaKitUpdateInput!, where: MediaKitWhereUniqueInput!): MediaKit
  updateManyMediaKits(data: MediaKitUpdateManyMutationInput!, where: MediaKitWhereInput): BatchPayload!
  upsertMediaKit(where: MediaKitWhereUniqueInput!, create: MediaKitCreateInput!, update: MediaKitUpdateInput!): MediaKit!
  deleteMediaKit(where: MediaKitWhereUniqueInput!): MediaKit
  deleteManyMediaKits(where: MediaKitWhereInput): BatchPayload!
  createSocial(data: SocialCreateInput!): Social!
  updateSocial(data: SocialUpdateInput!, where: SocialWhereUniqueInput!): Social
  updateManySocials(data: SocialUpdateManyMutationInput!, where: SocialWhereInput): BatchPayload!
  upsertSocial(where: SocialWhereUniqueInput!, create: SocialCreateInput!, update: SocialUpdateInput!): Social!
  deleteSocial(where: SocialWhereUniqueInput!): Social
  deleteManySocials(where: SocialWhereInput): BatchPayload!
  createTwitter(data: TwitterCreateInput!): Twitter!
  updateTwitter(data: TwitterUpdateInput!, where: TwitterWhereUniqueInput!): Twitter
  updateManyTwitters(data: TwitterUpdateManyMutationInput!, where: TwitterWhereInput): BatchPayload!
  upsertTwitter(where: TwitterWhereUniqueInput!, create: TwitterCreateInput!, update: TwitterUpdateInput!): Twitter!
  deleteTwitter(where: TwitterWhereUniqueInput!): Twitter
  deleteManyTwitters(where: TwitterWhereInput): BatchPayload!
  createYoutube(data: YoutubeCreateInput!): Youtube!
  updateYoutube(data: YoutubeUpdateInput!, where: YoutubeWhereUniqueInput!): Youtube
  updateManyYoutubes(data: YoutubeUpdateManyMutationInput!, where: YoutubeWhereInput): BatchPayload!
  upsertYoutube(where: YoutubeWhereUniqueInput!, create: YoutubeCreateInput!, update: YoutubeUpdateInput!): Youtube!
  deleteYoutube(where: YoutubeWhereUniqueInput!): Youtube
  deleteManyYoutubes(where: YoutubeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  feedback(where: FeedbackWhereUniqueInput!): Feedback
  feedbacks(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback]!
  feedbacksConnection(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  geo(where: GeoWhereUniqueInput!): Geo
  geos(where: GeoWhereInput, orderBy: GeoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Geo]!
  geosConnection(where: GeoWhereInput, orderBy: GeoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GeoConnection!
  influencer(where: InfluencerWhereUniqueInput!): Influencer
  influencers(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Influencer]!
  influencersConnection(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InfluencerConnection!
  instagram(where: InstagramWhereUniqueInput!): Instagram
  instagrams(where: InstagramWhereInput, orderBy: InstagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Instagram]!
  instagramsConnection(where: InstagramWhereInput, orderBy: InstagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InstagramConnection!
  interest(where: InterestWhereUniqueInput!): Interest
  interests(where: InterestWhereInput, orderBy: InterestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interest]!
  interestsConnection(where: InterestWhereInput, orderBy: InterestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InterestConnection!
  jobs(where: JobsWhereUniqueInput!): Jobs
  jobses(where: JobsWhereInput, orderBy: JobsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Jobs]!
  jobsesConnection(where: JobsWhereInput, orderBy: JobsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JobsConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  mediaKit(where: MediaKitWhereUniqueInput!): MediaKit
  mediaKits(where: MediaKitWhereInput, orderBy: MediaKitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MediaKit]!
  mediaKitsConnection(where: MediaKitWhereInput, orderBy: MediaKitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MediaKitConnection!
  social(where: SocialWhereUniqueInput!): Social
  socials(where: SocialWhereInput, orderBy: SocialOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Social]!
  socialsConnection(where: SocialWhereInput, orderBy: SocialOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SocialConnection!
  twitter(where: TwitterWhereUniqueInput!): Twitter
  twitters(where: TwitterWhereInput, orderBy: TwitterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Twitter]!
  twittersConnection(where: TwitterWhereInput, orderBy: TwitterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TwitterConnection!
  youtube(where: YoutubeWhereUniqueInput!): Youtube
  youtubes(where: YoutubeWhereInput, orderBy: YoutubeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Youtube]!
  youtubesConnection(where: YoutubeWhereInput, orderBy: YoutubeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): YoutubeConnection!
  node(id: ID!): Node
}

type Social {
  id: ID!
  status: Status!
  instagram: Instagram
  youtube: Youtube
  twitter: Twitter
  influencer: Influencer
  updatedAt: DateTime!
  createdAt: DateTime!
}

type SocialConnection {
  pageInfo: PageInfo!
  edges: [SocialEdge]!
  aggregate: AggregateSocial!
}

input SocialCreateInput {
  id: ID
  status: Status!
  instagram: InstagramCreateOneInput
  youtube: YoutubeCreateOneInput
  twitter: TwitterCreateOneInput
  influencer: InfluencerCreateOneWithoutSocialInput
}

input SocialCreateOneWithoutInfluencerInput {
  create: SocialCreateWithoutInfluencerInput
  connect: SocialWhereUniqueInput
}

input SocialCreateWithoutInfluencerInput {
  id: ID
  status: Status!
  instagram: InstagramCreateOneInput
  youtube: YoutubeCreateOneInput
  twitter: TwitterCreateOneInput
}

type SocialEdge {
  node: Social!
  cursor: String!
}

enum SocialOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type SocialPreviousValues {
  id: ID!
  status: Status!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type SocialSubscriptionPayload {
  mutation: MutationType!
  node: Social
  updatedFields: [String!]
  previousValues: SocialPreviousValues
}

input SocialSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SocialWhereInput
  AND: [SocialSubscriptionWhereInput!]
  OR: [SocialSubscriptionWhereInput!]
  NOT: [SocialSubscriptionWhereInput!]
}

input SocialUpdateInput {
  status: Status
  instagram: InstagramUpdateOneInput
  youtube: YoutubeUpdateOneInput
  twitter: TwitterUpdateOneInput
  influencer: InfluencerUpdateOneWithoutSocialInput
}

input SocialUpdateManyMutationInput {
  status: Status
}

input SocialUpdateOneWithoutInfluencerInput {
  create: SocialCreateWithoutInfluencerInput
  update: SocialUpdateWithoutInfluencerDataInput
  upsert: SocialUpsertWithoutInfluencerInput
  delete: Boolean
  disconnect: Boolean
  connect: SocialWhereUniqueInput
}

input SocialUpdateWithoutInfluencerDataInput {
  status: Status
  instagram: InstagramUpdateOneInput
  youtube: YoutubeUpdateOneInput
  twitter: TwitterUpdateOneInput
}

input SocialUpsertWithoutInfluencerInput {
  update: SocialUpdateWithoutInfluencerDataInput!
  create: SocialCreateWithoutInfluencerInput!
}

input SocialWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  instagram: InstagramWhereInput
  youtube: YoutubeWhereInput
  twitter: TwitterWhereInput
  influencer: InfluencerWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [SocialWhereInput!]
  OR: [SocialWhereInput!]
  NOT: [SocialWhereInput!]
}

input SocialWhereUniqueInput {
  id: ID
}

enum Status {
  DRAFT
  PUBLISHED
  ARCHIVED
}

type Subscription {
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  feedback(where: FeedbackSubscriptionWhereInput): FeedbackSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  geo(where: GeoSubscriptionWhereInput): GeoSubscriptionPayload
  influencer(where: InfluencerSubscriptionWhereInput): InfluencerSubscriptionPayload
  instagram(where: InstagramSubscriptionWhereInput): InstagramSubscriptionPayload
  interest(where: InterestSubscriptionWhereInput): InterestSubscriptionPayload
  jobs(where: JobsSubscriptionWhereInput): JobsSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  mediaKit(where: MediaKitSubscriptionWhereInput): MediaKitSubscriptionPayload
  social(where: SocialSubscriptionWhereInput): SocialSubscriptionPayload
  twitter(where: TwitterSubscriptionWhereInput): TwitterSubscriptionPayload
  youtube(where: YoutubeSubscriptionWhereInput): YoutubeSubscriptionPayload
}

type Twitter {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  analytics: Json
  followers: Int
  handle: String
  link: String
}

type TwitterConnection {
  pageInfo: PageInfo!
  edges: [TwitterEdge]!
  aggregate: AggregateTwitter!
}

input TwitterCreateInput {
  id: ID
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterCreateOneInput {
  create: TwitterCreateInput
  connect: TwitterWhereUniqueInput
}

type TwitterEdge {
  node: Twitter!
  cursor: String!
}

enum TwitterOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  analytics_ASC
  analytics_DESC
  followers_ASC
  followers_DESC
  handle_ASC
  handle_DESC
  link_ASC
  link_DESC
}

type TwitterPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  analytics: Json
  followers: Int
  handle: String
  link: String
}

type TwitterSubscriptionPayload {
  mutation: MutationType!
  node: Twitter
  updatedFields: [String!]
  previousValues: TwitterPreviousValues
}

input TwitterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TwitterWhereInput
  AND: [TwitterSubscriptionWhereInput!]
  OR: [TwitterSubscriptionWhereInput!]
  NOT: [TwitterSubscriptionWhereInput!]
}

input TwitterUpdateDataInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterUpdateInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterUpdateManyMutationInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterUpdateOneInput {
  create: TwitterCreateInput
  update: TwitterUpdateDataInput
  upsert: TwitterUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TwitterWhereUniqueInput
}

input TwitterUpsertNestedInput {
  update: TwitterUpdateDataInput!
  create: TwitterCreateInput!
}

input TwitterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  followers: Int
  followers_not: Int
  followers_in: [Int!]
  followers_not_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_gt: Int
  followers_gte: Int
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [TwitterWhereInput!]
  OR: [TwitterWhereInput!]
  NOT: [TwitterWhereInput!]
}

input TwitterWhereUniqueInput {
  id: ID
}

type Youtube {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  followers: Int
  analytics: Json
  handle: String
  link: String
}

type YoutubeConnection {
  pageInfo: PageInfo!
  edges: [YoutubeEdge]!
  aggregate: AggregateYoutube!
}

input YoutubeCreateInput {
  id: ID
  followers: Int
  analytics: Json
  handle: String
  link: String
}

input YoutubeCreateOneInput {
  create: YoutubeCreateInput
  connect: YoutubeWhereUniqueInput
}

type YoutubeEdge {
  node: Youtube!
  cursor: String!
}

enum YoutubeOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  followers_ASC
  followers_DESC
  analytics_ASC
  analytics_DESC
  handle_ASC
  handle_DESC
  link_ASC
  link_DESC
}

type YoutubePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  followers: Int
  analytics: Json
  handle: String
  link: String
}

type YoutubeSubscriptionPayload {
  mutation: MutationType!
  node: Youtube
  updatedFields: [String!]
  previousValues: YoutubePreviousValues
}

input YoutubeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: YoutubeWhereInput
  AND: [YoutubeSubscriptionWhereInput!]
  OR: [YoutubeSubscriptionWhereInput!]
  NOT: [YoutubeSubscriptionWhereInput!]
}

input YoutubeUpdateDataInput {
  followers: Int
  analytics: Json
  handle: String
  link: String
}

input YoutubeUpdateInput {
  followers: Int
  analytics: Json
  handle: String
  link: String
}

input YoutubeUpdateManyMutationInput {
  followers: Int
  analytics: Json
  handle: String
  link: String
}

input YoutubeUpdateOneInput {
  create: YoutubeCreateInput
  update: YoutubeUpdateDataInput
  upsert: YoutubeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: YoutubeWhereUniqueInput
}

input YoutubeUpsertNestedInput {
  update: YoutubeUpdateDataInput!
  create: YoutubeCreateInput!
}

input YoutubeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  followers: Int
  followers_not: Int
  followers_in: [Int!]
  followers_not_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_gt: Int
  followers_gte: Int
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [YoutubeWhereInput!]
  OR: [YoutubeWhereInput!]
  NOT: [YoutubeWhereInput!]
}

input YoutubeWhereUniqueInput {
  id: ID
}
