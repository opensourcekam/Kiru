### This file was autogenerated by Nexus 0.10.0
### Do not make changes to this file directly


type AggregateCompany {
  count: Int!
}

type AggregateFeedback {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateGeo {
  count: Int!
}

type AggregateInfluencer {
  count: Int!
}

type AggregateInstagram {
  count: Int!
}

type AggregateInterest {
  count: Int!
}

type AggregateJobs {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMediaKit {
  count: Int!
}

type AggregateSocial {
  count: Int!
}

type AggregateTwitter {
  count: Int!
}

type AggregateYoutube {
  count: Int!
}

type AuthPayload {
  influencer: Influencer
  token: String
}

type Company {
  createdAt: DateTime!
  feedback: Feedback
  hires: Influencer
  id: ID!
  jobs(after: String, before: String, first: Int, last: Int, orderBy: JobsOrderByInput, skip: Int, where: JobsWhereInput): [Jobs!]
  location: Json
  name: String
  status: Status!
  updatedAt: DateTime!
}

type CompanyConnection {
  aggregate: AggregateCompany!
  edges: [CompanyEdge!]!
  pageInfo: PageInfo!
}

type CompanyEdge {
  cursor: String!
  node: Company!
}

enum CompanyOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  location_ASC
  location_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  feedback: FeedbackWhereInput
  hires: InfluencerWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  jobs_every: JobsWhereInput
  jobs_none: JobsWhereInput
  jobs_some: JobsWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input CompanyWhereUniqueInput {
  id: ID
}

scalar DateTime

type Feedback {
  comment: String
  company: Company
  createdAt: DateTime!
  id: ID!
  influencer: Influencer
  status: Status!
  updatedAt: DateTime!
}

type FeedbackConnection {
  aggregate: AggregateFeedback!
  edges: [FeedbackEdge!]!
  pageInfo: PageInfo!
}

type FeedbackEdge {
  cursor: String!
  node: Feedback!
}

enum FeedbackOrderByInput {
  comment_ASC
  comment_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input FeedbackWhereInput {
  AND: [FeedbackWhereInput!]
  comment: String
  comment_contains: String
  comment_ends_with: String
  comment_gt: String
  comment_gte: String
  comment_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_not: String
  comment_not_contains: String
  comment_not_ends_with: String
  comment_not_in: [String!]
  comment_not_starts_with: String
  comment_starts_with: String
  company: CompanyWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  NOT: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input FeedbackWhereUniqueInput {
  id: ID
}

type File {
  contentType: String!
  createdAt: DateTime!
  height: Int
  id: ID!
  influencer: Influencer!
  mediaKit(after: String, before: String, first: Int, last: Int, orderBy: MediaKitOrderByInput, skip: Int, where: MediaKitWhereInput): [MediaKit!]
  name: String!
  public_id: String!
  resource_type: String
  secret: String!
  size: Int!
  updatedAt: DateTime!
  url: String!
  width: Int
}

type FileConnection {
  aggregate: AggregateFile!
  edges: [FileEdge!]!
  pageInfo: PageInfo!
}

input FileCreateManyWithoutInfluencerInput {
  connect: [FileWhereUniqueInput!]
  create: [FileCreateWithoutInfluencerInput!]
}

input FileCreateManyWithoutMediaKitInput {
  connect: [FileWhereUniqueInput!]
  create: [FileCreateWithoutMediaKitInput!]
}

input FileCreateWithoutInfluencerInput {
  contentType: String!
  height: Int
  mediaKit: MediaKitCreateManyWithoutFilesInput
  name: String!
  public_id: String!
  resource_type: String
  secret: String!
  size: Int!
  url: String!
  width: Int
}

input FileCreateWithoutMediaKitInput {
  contentType: String!
  height: Int
  influencer: InfluencerCreateOneWithoutFilesInput!
  name: String!
  public_id: String!
  resource_type: String
  secret: String!
  size: Int!
  url: String!
  width: Int
}

type FileEdge {
  cursor: String!
  node: File!
}

enum FileOrderByInput {
  contentType_ASC
  contentType_DESC
  createdAt_ASC
  createdAt_DESC
  height_ASC
  height_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  public_id_ASC
  public_id_DESC
  resource_type_ASC
  resource_type_DESC
  secret_ASC
  secret_DESC
  size_ASC
  size_DESC
  updatedAt_ASC
  updatedAt_DESC
  url_ASC
  url_DESC
  width_ASC
  width_DESC
}

input FileScalarWhereInput {
  AND: [FileScalarWhereInput!]
  contentType: String
  contentType_contains: String
  contentType_ends_with: String
  contentType_gt: String
  contentType_gte: String
  contentType_in: [String!]
  contentType_lt: String
  contentType_lte: String
  contentType_not: String
  contentType_not_contains: String
  contentType_not_ends_with: String
  contentType_not_in: [String!]
  contentType_not_starts_with: String
  contentType_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  height: Int
  height_gt: Int
  height_gte: Int
  height_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_not: Int
  height_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [FileScalarWhereInput!]
  OR: [FileScalarWhereInput!]
  public_id: String
  public_id_contains: String
  public_id_ends_with: String
  public_id_gt: String
  public_id_gte: String
  public_id_in: [String!]
  public_id_lt: String
  public_id_lte: String
  public_id_not: String
  public_id_not_contains: String
  public_id_not_ends_with: String
  public_id_not_in: [String!]
  public_id_not_starts_with: String
  public_id_starts_with: String
  resource_type: String
  resource_type_contains: String
  resource_type_ends_with: String
  resource_type_gt: String
  resource_type_gte: String
  resource_type_in: [String!]
  resource_type_lt: String
  resource_type_lte: String
  resource_type_not: String
  resource_type_not_contains: String
  resource_type_not_ends_with: String
  resource_type_not_in: [String!]
  resource_type_not_starts_with: String
  resource_type_starts_with: String
  secret: String
  secret_contains: String
  secret_ends_with: String
  secret_gt: String
  secret_gte: String
  secret_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_not: String
  secret_not_contains: String
  secret_not_ends_with: String
  secret_not_in: [String!]
  secret_not_starts_with: String
  secret_starts_with: String
  size: Int
  size_gt: Int
  size_gte: Int
  size_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_not: Int
  size_not_in: [Int!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  url: String
  url_contains: String
  url_ends_with: String
  url_gt: String
  url_gte: String
  url_in: [String!]
  url_lt: String
  url_lte: String
  url_not: String
  url_not_contains: String
  url_not_ends_with: String
  url_not_in: [String!]
  url_not_starts_with: String
  url_starts_with: String
  width: Int
  width_gt: Int
  width_gte: Int
  width_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_not: Int
  width_not_in: [Int!]
}

input FileUpdateManyDataInput {
  contentType: String
  height: Int
  name: String
  public_id: String
  resource_type: String
  secret: String
  size: Int
  url: String
  width: Int
}

input FileUpdateManyWithoutInfluencerInput {
  connect: [FileWhereUniqueInput!]
  create: [FileCreateWithoutInfluencerInput!]
  delete: [FileWhereUniqueInput!]
  deleteMany: [FileScalarWhereInput!]
  disconnect: [FileWhereUniqueInput!]
  set: [FileWhereUniqueInput!]
  update: [FileUpdateWithWhereUniqueWithoutInfluencerInput!]
  updateMany: [FileUpdateManyWithWhereNestedInput!]
  upsert: [FileUpsertWithWhereUniqueWithoutInfluencerInput!]
}

input FileUpdateManyWithoutMediaKitInput {
  connect: [FileWhereUniqueInput!]
  create: [FileCreateWithoutMediaKitInput!]
  delete: [FileWhereUniqueInput!]
  deleteMany: [FileScalarWhereInput!]
  disconnect: [FileWhereUniqueInput!]
  set: [FileWhereUniqueInput!]
  update: [FileUpdateWithWhereUniqueWithoutMediaKitInput!]
  updateMany: [FileUpdateManyWithWhereNestedInput!]
  upsert: [FileUpsertWithWhereUniqueWithoutMediaKitInput!]
}

input FileUpdateManyWithWhereNestedInput {
  data: FileUpdateManyDataInput!
  where: FileScalarWhereInput!
}

input FileUpdateWithoutInfluencerDataInput {
  contentType: String
  height: Int
  mediaKit: MediaKitUpdateManyWithoutFilesInput
  name: String
  public_id: String
  resource_type: String
  secret: String
  size: Int
  url: String
  width: Int
}

input FileUpdateWithoutMediaKitDataInput {
  contentType: String
  height: Int
  influencer: InfluencerUpdateOneRequiredWithoutFilesInput
  name: String
  public_id: String
  resource_type: String
  secret: String
  size: Int
  url: String
  width: Int
}

input FileUpdateWithWhereUniqueWithoutInfluencerInput {
  data: FileUpdateWithoutInfluencerDataInput!
  where: FileWhereUniqueInput!
}

input FileUpdateWithWhereUniqueWithoutMediaKitInput {
  data: FileUpdateWithoutMediaKitDataInput!
  where: FileWhereUniqueInput!
}

input FileUpsertWithWhereUniqueWithoutInfluencerInput {
  create: FileCreateWithoutInfluencerInput!
  update: FileUpdateWithoutInfluencerDataInput!
  where: FileWhereUniqueInput!
}

input FileUpsertWithWhereUniqueWithoutMediaKitInput {
  create: FileCreateWithoutMediaKitInput!
  update: FileUpdateWithoutMediaKitDataInput!
  where: FileWhereUniqueInput!
}

input FileWhereInput {
  AND: [FileWhereInput!]
  contentType: String
  contentType_contains: String
  contentType_ends_with: String
  contentType_gt: String
  contentType_gte: String
  contentType_in: [String!]
  contentType_lt: String
  contentType_lte: String
  contentType_not: String
  contentType_not_contains: String
  contentType_not_ends_with: String
  contentType_not_in: [String!]
  contentType_not_starts_with: String
  contentType_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  height: Int
  height_gt: Int
  height_gte: Int
  height_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_not: Int
  height_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  mediaKit_every: MediaKitWhereInput
  mediaKit_none: MediaKitWhereInput
  mediaKit_some: MediaKitWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  public_id: String
  public_id_contains: String
  public_id_ends_with: String
  public_id_gt: String
  public_id_gte: String
  public_id_in: [String!]
  public_id_lt: String
  public_id_lte: String
  public_id_not: String
  public_id_not_contains: String
  public_id_not_ends_with: String
  public_id_not_in: [String!]
  public_id_not_starts_with: String
  public_id_starts_with: String
  resource_type: String
  resource_type_contains: String
  resource_type_ends_with: String
  resource_type_gt: String
  resource_type_gte: String
  resource_type_in: [String!]
  resource_type_lt: String
  resource_type_lte: String
  resource_type_not: String
  resource_type_not_contains: String
  resource_type_not_ends_with: String
  resource_type_not_in: [String!]
  resource_type_not_starts_with: String
  resource_type_starts_with: String
  secret: String
  secret_contains: String
  secret_ends_with: String
  secret_gt: String
  secret_gte: String
  secret_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_not: String
  secret_not_contains: String
  secret_not_ends_with: String
  secret_not_in: [String!]
  secret_not_starts_with: String
  secret_starts_with: String
  size: Int
  size_gt: Int
  size_gte: Int
  size_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_not: Int
  size_not_in: [Int!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  url: String
  url_contains: String
  url_ends_with: String
  url_gt: String
  url_gte: String
  url_in: [String!]
  url_lt: String
  url_lte: String
  url_not: String
  url_not_contains: String
  url_not_ends_with: String
  url_not_in: [String!]
  url_not_starts_with: String
  url_starts_with: String
  width: Int
  width_gt: Int
  width_gte: Int
  width_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_not: Int
  width_not_in: [Int!]
}

input FileWhereUniqueInput {
  id: ID
  secret: String
  url: String
}

type Geo {
  createdAt: DateTime!
  id: ID!
  lat: Float
  lng: Float
  location: Location
  updatedAt: DateTime!
}

type GeoConnection {
  aggregate: AggregateGeo!
  edges: [GeoEdge!]!
  pageInfo: PageInfo!
}

input GeoCreateOneWithoutLocationInput {
  connect: GeoWhereUniqueInput
  create: GeoCreateWithoutLocationInput
}

input GeoCreateWithoutLocationInput {
  lat: Float
  lng: Float
}

type GeoEdge {
  cursor: String!
  node: Geo!
}

enum GeoOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GeoUpdateOneWithoutLocationInput {
  connect: GeoWhereUniqueInput
  create: GeoCreateWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  update: GeoUpdateWithoutLocationDataInput
  upsert: GeoUpsertWithoutLocationInput
}

input GeoUpdateWithoutLocationDataInput {
  lat: Float
  lng: Float
}

input GeoUpsertWithoutLocationInput {
  create: GeoCreateWithoutLocationInput!
  update: GeoUpdateWithoutLocationDataInput!
}

input GeoWhereInput {
  AND: [GeoWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lat: Float
  lat_gt: Float
  lat_gte: Float
  lat_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_not: Float
  lat_not_in: [Float!]
  lng: Float
  lng_gt: Float
  lng_gte: Float
  lng_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_not: Float
  lng_not_in: [Float!]
  location: LocationWhereInput
  NOT: [GeoWhereInput!]
  OR: [GeoWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GeoWhereUniqueInput {
  id: ID
}

type Influencer {
  avatar: String
  bio: String
  createdAt: DateTime!
  email: String!
  files(after: String, before: String, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): [File!]
  handle: String
  id: ID!
  location: Location
  mediaKit(after: String, before: String, first: Int, last: Int, orderBy: MediaKitOrderByInput, skip: Int, where: MediaKitWhereInput): [MediaKit!]
  name: String
  social: Social
  updatedAt: DateTime!
}

type InfluencerConnection {
  aggregate: AggregateInfluencer!
  edges: [InfluencerEdge!]!
  pageInfo: PageInfo!
}

input InfluencerCreateInput {
  avatar: String
  bio: String
  email: String!
  files: FileCreateManyWithoutInfluencerInput
  handle: String
  location: LocationCreateOneWithoutInfluencerInput
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  name: String
  password: String!
  social: SocialCreateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerCreateOneInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateInput
}

input InfluencerCreateOneWithoutFilesInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateWithoutFilesInput
}

input InfluencerCreateOneWithoutMediaKitInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateWithoutMediaKitInput
}

input InfluencerCreateWithoutFilesInput {
  avatar: String
  bio: String
  email: String!
  handle: String
  location: LocationCreateOneWithoutInfluencerInput
  mediaKit: MediaKitCreateManyWithoutInfluencerInput
  name: String
  password: String!
  social: SocialCreateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerCreateWithoutMediaKitInput {
  avatar: String
  bio: String
  email: String!
  files: FileCreateManyWithoutInfluencerInput
  handle: String
  location: LocationCreateOneWithoutInfluencerInput
  name: String
  password: String!
  social: SocialCreateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

type InfluencerEdge {
  cursor: String!
  node: Influencer!
}

enum InfluencerOrderByInput {
  avatar_ASC
  avatar_DESC
  bio_ASC
  bio_DESC
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  handle_ASC
  handle_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  specialty_ASC
  specialty_DESC
  updatedAt_ASC
  updatedAt_DESC
  verified_ASC
  verified_DESC
}

input InfluencerUpdateDataInput {
  avatar: String
  bio: String
  email: String
  files: FileUpdateManyWithoutInfluencerInput
  handle: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  name: String
  password: String
  social: SocialUpdateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerUpdateInput {
  avatar: String
  bio: String
  email: String
  files: FileUpdateManyWithoutInfluencerInput
  handle: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  name: String
  password: String
  social: SocialUpdateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerUpdateOneInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateInput
  delete: Boolean
  disconnect: Boolean
  update: InfluencerUpdateDataInput
  upsert: InfluencerUpsertNestedInput
}

input InfluencerUpdateOneRequiredWithoutFilesInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateWithoutFilesInput
  update: InfluencerUpdateWithoutFilesDataInput
  upsert: InfluencerUpsertWithoutFilesInput
}

input InfluencerUpdateOneWithoutMediaKitInput {
  connect: InfluencerWhereUniqueInput
  create: InfluencerCreateWithoutMediaKitInput
  delete: Boolean
  disconnect: Boolean
  update: InfluencerUpdateWithoutMediaKitDataInput
  upsert: InfluencerUpsertWithoutMediaKitInput
}

input InfluencerUpdateWithoutFilesDataInput {
  avatar: String
  bio: String
  email: String
  handle: String
  location: LocationUpdateOneWithoutInfluencerInput
  mediaKit: MediaKitUpdateManyWithoutInfluencerInput
  name: String
  password: String
  social: SocialUpdateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerUpdateWithoutMediaKitDataInput {
  avatar: String
  bio: String
  email: String
  files: FileUpdateManyWithoutInfluencerInput
  handle: String
  location: LocationUpdateOneWithoutInfluencerInput
  name: String
  password: String
  social: SocialUpdateOneWithoutInfluencerInput
  specialty: String
  verified: Boolean
}

input InfluencerUpsertNestedInput {
  create: InfluencerCreateInput!
  update: InfluencerUpdateDataInput!
}

input InfluencerUpsertWithoutFilesInput {
  create: InfluencerCreateWithoutFilesInput!
  update: InfluencerUpdateWithoutFilesDataInput!
}

input InfluencerUpsertWithoutMediaKitInput {
  create: InfluencerCreateWithoutMediaKitInput!
  update: InfluencerUpdateWithoutMediaKitDataInput!
}

input InfluencerWhereInput {
  AND: [InfluencerWhereInput!]
  avatar: String
  avatar_contains: String
  avatar_ends_with: String
  avatar_gt: String
  avatar_gte: String
  avatar_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_not: String
  avatar_not_contains: String
  avatar_not_ends_with: String
  avatar_not_in: [String!]
  avatar_not_starts_with: String
  avatar_starts_with: String
  bio: String
  bio_contains: String
  bio_ends_with: String
  bio_gt: String
  bio_gte: String
  bio_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_not: String
  bio_not_contains: String
  bio_not_ends_with: String
  bio_not_in: [String!]
  bio_not_starts_with: String
  bio_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  files_every: FileWhereInput
  files_none: FileWhereInput
  files_some: FileWhereInput
  handle: String
  handle_contains: String
  handle_ends_with: String
  handle_gt: String
  handle_gte: String
  handle_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_not: String
  handle_not_contains: String
  handle_not_ends_with: String
  handle_not_in: [String!]
  handle_not_starts_with: String
  handle_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  location: LocationWhereInput
  mediaKit_every: MediaKitWhereInput
  mediaKit_none: MediaKitWhereInput
  mediaKit_some: MediaKitWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [InfluencerWhereInput!]
  OR: [InfluencerWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  social: SocialWhereInput
  specialty: String
  specialty_contains: String
  specialty_ends_with: String
  specialty_gt: String
  specialty_gte: String
  specialty_in: [String!]
  specialty_lt: String
  specialty_lte: String
  specialty_not: String
  specialty_not_contains: String
  specialty_not_ends_with: String
  specialty_not_in: [String!]
  specialty_not_starts_with: String
  specialty_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  verified: Boolean
  verified_not: Boolean
}

input InfluencerWhereUniqueInput {
  email: String
  handle: String
  id: ID
}

type Instagram {
  analytics: Json
  createdAt: DateTime!
  followers: Int
  handle: String
  id: ID!
  link: String
  updatedAt: DateTime!
}

type InstagramConnection {
  aggregate: AggregateInstagram!
  edges: [InstagramEdge!]!
  pageInfo: PageInfo!
}

input InstagramCreateInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input InstagramCreateOneInput {
  connect: InstagramWhereUniqueInput
  create: InstagramCreateInput
}

type InstagramEdge {
  cursor: String!
  node: Instagram!
}

enum InstagramOrderByInput {
  analytics_ASC
  analytics_DESC
  createdAt_ASC
  createdAt_DESC
  followers_ASC
  followers_DESC
  handle_ASC
  handle_DESC
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input InstagramUpdateDataInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input InstagramUpdateOneInput {
  connect: InstagramWhereUniqueInput
  create: InstagramCreateInput
  delete: Boolean
  disconnect: Boolean
  update: InstagramUpdateDataInput
  upsert: InstagramUpsertNestedInput
}

input InstagramUpsertNestedInput {
  create: InstagramCreateInput!
  update: InstagramUpdateDataInput!
}

input InstagramWhereInput {
  AND: [InstagramWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  followers: Int
  followers_gt: Int
  followers_gte: Int
  followers_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_not: Int
  followers_not_in: [Int!]
  handle: String
  handle_contains: String
  handle_ends_with: String
  handle_gt: String
  handle_gte: String
  handle_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_not: String
  handle_not_contains: String
  handle_not_ends_with: String
  handle_not_in: [String!]
  handle_not_starts_with: String
  handle_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  link: String
  link_contains: String
  link_ends_with: String
  link_gt: String
  link_gte: String
  link_in: [String!]
  link_lt: String
  link_lte: String
  link_not: String
  link_not_contains: String
  link_not_ends_with: String
  link_not_in: [String!]
  link_not_starts_with: String
  link_starts_with: String
  NOT: [InstagramWhereInput!]
  OR: [InstagramWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InstagramWhereUniqueInput {
  id: ID
}

type Interest {
  createdAt: DateTime!
  id: ID!
  influencer: Influencer
  tag: String
  updatedAt: DateTime!
}

type InterestConnection {
  aggregate: AggregateInterest!
  edges: [InterestEdge!]!
  pageInfo: PageInfo!
}

input InterestCreateInput {
  influencer: InfluencerCreateOneInput
  tag: String
}

input InterestCreateManyInput {
  connect: [InterestWhereUniqueInput!]
  create: [InterestCreateInput!]
}

type InterestEdge {
  cursor: String!
  node: Interest!
}

enum InterestOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  tag_ASC
  tag_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input InterestScalarWhereInput {
  AND: [InterestScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [InterestScalarWhereInput!]
  OR: [InterestScalarWhereInput!]
  tag: String
  tag_contains: String
  tag_ends_with: String
  tag_gt: String
  tag_gte: String
  tag_in: [String!]
  tag_lt: String
  tag_lte: String
  tag_not: String
  tag_not_contains: String
  tag_not_ends_with: String
  tag_not_in: [String!]
  tag_not_starts_with: String
  tag_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InterestUpdateDataInput {
  influencer: InfluencerUpdateOneInput
  tag: String
}

input InterestUpdateManyDataInput {
  tag: String
}

input InterestUpdateManyInput {
  connect: [InterestWhereUniqueInput!]
  create: [InterestCreateInput!]
  delete: [InterestWhereUniqueInput!]
  deleteMany: [InterestScalarWhereInput!]
  disconnect: [InterestWhereUniqueInput!]
  set: [InterestWhereUniqueInput!]
  update: [InterestUpdateWithWhereUniqueNestedInput!]
  updateMany: [InterestUpdateManyWithWhereNestedInput!]
  upsert: [InterestUpsertWithWhereUniqueNestedInput!]
}

input InterestUpdateManyWithWhereNestedInput {
  data: InterestUpdateManyDataInput!
  where: InterestScalarWhereInput!
}

input InterestUpdateWithWhereUniqueNestedInput {
  data: InterestUpdateDataInput!
  where: InterestWhereUniqueInput!
}

input InterestUpsertWithWhereUniqueNestedInput {
  create: InterestCreateInput!
  update: InterestUpdateDataInput!
  where: InterestWhereUniqueInput!
}

input InterestWhereInput {
  AND: [InterestWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  NOT: [InterestWhereInput!]
  OR: [InterestWhereInput!]
  tag: String
  tag_contains: String
  tag_ends_with: String
  tag_gt: String
  tag_gte: String
  tag_in: [String!]
  tag_lt: String
  tag_lte: String
  tag_not: String
  tag_not_contains: String
  tag_not_ends_with: String
  tag_not_in: [String!]
  tag_not_starts_with: String
  tag_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InterestWhereUniqueInput {
  id: ID
}

type Jobs {
  accepted: Boolean
  company: Company
  cost: String
  createdAt: DateTime!
  id: ID!
  status: Status!
  updatedAt: DateTime!
}

type JobsConnection {
  aggregate: AggregateJobs!
  edges: [JobsEdge!]!
  pageInfo: PageInfo!
}

type JobsEdge {
  cursor: String!
  node: Jobs!
}

enum JobsOrderByInput {
  accepted_ASC
  accepted_DESC
  cost_ASC
  cost_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input JobsWhereInput {
  accepted: Boolean
  accepted_not: Boolean
  AND: [JobsWhereInput!]
  company: CompanyWhereInput
  cost: String
  cost_contains: String
  cost_ends_with: String
  cost_gt: String
  cost_gte: String
  cost_in: [String!]
  cost_lt: String
  cost_lte: String
  cost_not: String
  cost_not_contains: String
  cost_not_ends_with: String
  cost_not_in: [String!]
  cost_not_starts_with: String
  cost_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [JobsWhereInput!]
  OR: [JobsWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input JobsWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  createdAt: DateTime!
  geo: Geo
  id: ID!
  influencer: Influencer
  name: String
  updatedAt: DateTime!
}

type LocationConnection {
  aggregate: AggregateLocation!
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
}

input LocationCreateOneWithoutInfluencerInput {
  connect: LocationWhereUniqueInput
  create: LocationCreateWithoutInfluencerInput
}

input LocationCreateWithoutInfluencerInput {
  geo: GeoCreateOneWithoutLocationInput
  name: String
}

type LocationEdge {
  cursor: String!
  node: Location!
}

enum LocationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input LocationUpdateOneWithoutInfluencerInput {
  connect: LocationWhereUniqueInput
  create: LocationCreateWithoutInfluencerInput
  delete: Boolean
  disconnect: Boolean
  update: LocationUpdateWithoutInfluencerDataInput
  upsert: LocationUpsertWithoutInfluencerInput
}

input LocationUpdateWithoutInfluencerDataInput {
  geo: GeoUpdateOneWithoutLocationInput
  name: String
}

input LocationUpsertWithoutInfluencerInput {
  create: LocationCreateWithoutInfluencerInput!
  update: LocationUpdateWithoutInfluencerDataInput!
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  geo: GeoWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input LocationWhereUniqueInput {
  id: ID
}

type MediaKit {
  createdAt: DateTime!
  files(after: String, before: String, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): [File!]
  id: ID!
  influencer: Influencer
  interests(after: String, before: String, first: Int, last: Int, orderBy: InterestOrderByInput, skip: Int, where: InterestWhereInput): [Interest!]
  status: Status!
  updatedAt: DateTime!
}

type MediaKitConnection {
  aggregate: AggregateMediaKit!
  edges: [MediaKitEdge!]!
  pageInfo: PageInfo!
}

input MediaKitCreateManyWithoutFilesInput {
  connect: [MediaKitWhereUniqueInput!]
  create: [MediaKitCreateWithoutFilesInput!]
}

input MediaKitCreateManyWithoutInfluencerInput {
  connect: [MediaKitWhereUniqueInput!]
  create: [MediaKitCreateWithoutInfluencerInput!]
}

input MediaKitCreateWithoutFilesInput {
  influencer: InfluencerCreateOneWithoutMediaKitInput
  interests: InterestCreateManyInput
  status: Status
}

input MediaKitCreateWithoutInfluencerInput {
  files: FileCreateManyWithoutMediaKitInput
  interests: InterestCreateManyInput
  status: Status
}

type MediaKitEdge {
  cursor: String!
  node: MediaKit!
}

enum MediaKitOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input MediaKitScalarWhereInput {
  AND: [MediaKitScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [MediaKitScalarWhereInput!]
  OR: [MediaKitScalarWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input MediaKitUpdateManyDataInput {
  status: Status
}

input MediaKitUpdateManyWithoutFilesInput {
  connect: [MediaKitWhereUniqueInput!]
  create: [MediaKitCreateWithoutFilesInput!]
  delete: [MediaKitWhereUniqueInput!]
  deleteMany: [MediaKitScalarWhereInput!]
  disconnect: [MediaKitWhereUniqueInput!]
  set: [MediaKitWhereUniqueInput!]
  update: [MediaKitUpdateWithWhereUniqueWithoutFilesInput!]
  updateMany: [MediaKitUpdateManyWithWhereNestedInput!]
  upsert: [MediaKitUpsertWithWhereUniqueWithoutFilesInput!]
}

input MediaKitUpdateManyWithoutInfluencerInput {
  connect: [MediaKitWhereUniqueInput!]
  create: [MediaKitCreateWithoutInfluencerInput!]
  delete: [MediaKitWhereUniqueInput!]
  deleteMany: [MediaKitScalarWhereInput!]
  disconnect: [MediaKitWhereUniqueInput!]
  set: [MediaKitWhereUniqueInput!]
  update: [MediaKitUpdateWithWhereUniqueWithoutInfluencerInput!]
  updateMany: [MediaKitUpdateManyWithWhereNestedInput!]
  upsert: [MediaKitUpsertWithWhereUniqueWithoutInfluencerInput!]
}

input MediaKitUpdateManyWithWhereNestedInput {
  data: MediaKitUpdateManyDataInput!
  where: MediaKitScalarWhereInput!
}

input MediaKitUpdateWithoutFilesDataInput {
  influencer: InfluencerUpdateOneWithoutMediaKitInput
  interests: InterestUpdateManyInput
  status: Status
}

input MediaKitUpdateWithoutInfluencerDataInput {
  files: FileUpdateManyWithoutMediaKitInput
  interests: InterestUpdateManyInput
  status: Status
}

input MediaKitUpdateWithWhereUniqueWithoutFilesInput {
  data: MediaKitUpdateWithoutFilesDataInput!
  where: MediaKitWhereUniqueInput!
}

input MediaKitUpdateWithWhereUniqueWithoutInfluencerInput {
  data: MediaKitUpdateWithoutInfluencerDataInput!
  where: MediaKitWhereUniqueInput!
}

input MediaKitUpsertWithWhereUniqueWithoutFilesInput {
  create: MediaKitCreateWithoutFilesInput!
  update: MediaKitUpdateWithoutFilesDataInput!
  where: MediaKitWhereUniqueInput!
}

input MediaKitUpsertWithWhereUniqueWithoutInfluencerInput {
  create: MediaKitCreateWithoutInfluencerInput!
  update: MediaKitUpdateWithoutInfluencerDataInput!
  where: MediaKitWhereUniqueInput!
}

input MediaKitWhereInput {
  AND: [MediaKitWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  files_every: FileWhereInput
  files_none: FileWhereInput
  files_some: FileWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  interests_every: InterestWhereInput
  interests_none: InterestWhereInput
  interests_some: InterestWhereInput
  NOT: [MediaKitWhereInput!]
  OR: [MediaKitWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input MediaKitWhereUniqueInput {
  id: ID
}

type Mutation {
  createInterest(tag: String): Interest
  login(email: String, password: String): AuthPayload
  logout: Boolean
  signS3(contentType: String!, size: Int!): S3Payload
  signup(email: String, name: String!, password: String): AuthPayload
  updateInfluencer(data: InfluencerUpdateInput!): Influencer
  uploadFile(contentType: String, height: Int, name: String, public_id: String, secret: String, size: Int, url: String, width: Int): File
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  companies(after: String, before: String, first: Int, last: Int, orderBy: CompanyOrderByInput, skip: Int, where: CompanyWhereInput): [Company!]!
  companiesConnection(after: String, before: String, first: Int, last: Int, orderBy: CompanyOrderByInput, skip: Int, where: CompanyWhereInput): CompanyConnection!
  company(where: CompanyWhereUniqueInput!): Company
  feedback(where: FeedbackWhereUniqueInput!): Feedback
  feedbacks(after: String, before: String, first: Int, last: Int, orderBy: FeedbackOrderByInput, skip: Int, where: FeedbackWhereInput): [Feedback!]!
  feedbacksConnection(after: String, before: String, first: Int, last: Int, orderBy: FeedbackOrderByInput, skip: Int, where: FeedbackWhereInput): FeedbackConnection!
  file(where: FileWhereUniqueInput!): File
  files: [File!]
  filesConnection(after: String, before: String, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): FileConnection!
  geo(where: GeoWhereUniqueInput!): Geo
  geos(after: String, before: String, first: Int, last: Int, orderBy: GeoOrderByInput, skip: Int, where: GeoWhereInput): [Geo!]!
  geosConnection(after: String, before: String, first: Int, last: Int, orderBy: GeoOrderByInput, skip: Int, where: GeoWhereInput): GeoConnection!
  influencer(where: InfluencerWhereUniqueInput!): Influencer
  influencers(after: String, before: String, first: Int, last: Int, orderBy: InfluencerOrderByInput, skip: Int, where: InfluencerWhereInput): [Influencer!]!
  influencersConnection(after: String, before: String, first: Int, last: Int, orderBy: InfluencerOrderByInput, skip: Int, where: InfluencerWhereInput): InfluencerConnection!
  instagram(where: InstagramWhereUniqueInput!): Instagram
  instagrams(after: String, before: String, first: Int, last: Int, orderBy: InstagramOrderByInput, skip: Int, where: InstagramWhereInput): [Instagram!]!
  instagramsConnection(after: String, before: String, first: Int, last: Int, orderBy: InstagramOrderByInput, skip: Int, where: InstagramWhereInput): InstagramConnection!
  interest(where: InterestWhereUniqueInput!): Interest
  interests(after: String, before: String, first: Int, last: Int, orderBy: InterestOrderByInput, skip: Int, where: InterestWhereInput): [Interest!]!
  interestsConnection(after: String, before: String, first: Int, last: Int, orderBy: InterestOrderByInput, skip: Int, where: InterestWhereInput): InterestConnection!
  jobs(where: JobsWhereUniqueInput!): Jobs
  jobses(after: String, before: String, first: Int, last: Int, orderBy: JobsOrderByInput, skip: Int, where: JobsWhereInput): [Jobs!]!
  jobsesConnection(after: String, before: String, first: Int, last: Int, orderBy: JobsOrderByInput, skip: Int, where: JobsWhereInput): JobsConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): [Location!]!
  locationsConnection(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): LocationConnection!
  me: Influencer
  mediaKit(where: MediaKitWhereUniqueInput!): MediaKit
  mediaKits(after: String, before: String, first: Int, last: Int, orderBy: MediaKitOrderByInput, skip: Int, where: MediaKitWhereInput): [MediaKit!]!
  mediaKitsConnection(after: String, before: String, first: Int, last: Int, orderBy: MediaKitOrderByInput, skip: Int, where: MediaKitWhereInput): MediaKitConnection!
  social: Social
  socials(after: String, before: String, first: Int, last: Int, orderBy: SocialOrderByInput, skip: Int, where: SocialWhereInput): [Social!]!
  socialsConnection(after: String, before: String, first: Int, last: Int, orderBy: SocialOrderByInput, skip: Int, where: SocialWhereInput): SocialConnection!
  twitter(where: TwitterWhereUniqueInput!): Twitter
  twitters(after: String, before: String, first: Int, last: Int, orderBy: TwitterOrderByInput, skip: Int, where: TwitterWhereInput): [Twitter!]!
  twittersConnection(after: String, before: String, first: Int, last: Int, orderBy: TwitterOrderByInput, skip: Int, where: TwitterWhereInput): TwitterConnection!
  youtube(where: YoutubeWhereUniqueInput!): Youtube
  youtubes(after: String, before: String, first: Int, last: Int, orderBy: YoutubeOrderByInput, skip: Int, where: YoutubeWhereInput): [Youtube!]!
  youtubesConnection(after: String, before: String, first: Int, last: Int, orderBy: YoutubeOrderByInput, skip: Int, where: YoutubeWhereInput): YoutubeConnection!
}

type S3Payload {
  id: String
  signedRequest: String
  url: String
}

type Social {
  createdAt: DateTime!
  id: ID!
  influencer: Influencer
  instagram: Instagram
  status: Status!
  twitter: Twitter
  updatedAt: DateTime!
  youtube: Youtube
}

type SocialConnection {
  aggregate: AggregateSocial!
  edges: [SocialEdge!]!
  pageInfo: PageInfo!
}

input SocialCreateOneWithoutInfluencerInput {
  connect: SocialWhereUniqueInput
  create: SocialCreateWithoutInfluencerInput
}

input SocialCreateWithoutInfluencerInput {
  instagram: InstagramCreateOneInput
  status: Status!
  twitter: TwitterCreateOneInput
  youtube: YoutubeCreateOneInput
}

type SocialEdge {
  cursor: String!
  node: Social!
}

enum SocialOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SocialUpdateOneWithoutInfluencerInput {
  connect: SocialWhereUniqueInput
  create: SocialCreateWithoutInfluencerInput
  delete: Boolean
  disconnect: Boolean
  update: SocialUpdateWithoutInfluencerDataInput
  upsert: SocialUpsertWithoutInfluencerInput
}

input SocialUpdateWithoutInfluencerDataInput {
  instagram: InstagramUpdateOneInput
  status: Status
  twitter: TwitterUpdateOneInput
  youtube: YoutubeUpdateOneInput
}

input SocialUpsertWithoutInfluencerInput {
  create: SocialCreateWithoutInfluencerInput!
  update: SocialUpdateWithoutInfluencerDataInput!
}

input SocialWhereInput {
  AND: [SocialWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  influencer: InfluencerWhereInput
  instagram: InstagramWhereInput
  NOT: [SocialWhereInput!]
  OR: [SocialWhereInput!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  twitter: TwitterWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  youtube: YoutubeWhereInput
}

input SocialWhereUniqueInput {
  id: ID
}

enum Status {
  ARCHIVED
  DRAFT
  PUBLISHED
}

type Twitter {
  analytics: Json
  createdAt: DateTime!
  followers: Int
  handle: String
  id: ID!
  link: String
  updatedAt: DateTime!
}

type TwitterConnection {
  aggregate: AggregateTwitter!
  edges: [TwitterEdge!]!
  pageInfo: PageInfo!
}

input TwitterCreateInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterCreateOneInput {
  connect: TwitterWhereUniqueInput
  create: TwitterCreateInput
}

type TwitterEdge {
  cursor: String!
  node: Twitter!
}

enum TwitterOrderByInput {
  analytics_ASC
  analytics_DESC
  createdAt_ASC
  createdAt_DESC
  followers_ASC
  followers_DESC
  handle_ASC
  handle_DESC
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TwitterUpdateDataInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input TwitterUpdateOneInput {
  connect: TwitterWhereUniqueInput
  create: TwitterCreateInput
  delete: Boolean
  disconnect: Boolean
  update: TwitterUpdateDataInput
  upsert: TwitterUpsertNestedInput
}

input TwitterUpsertNestedInput {
  create: TwitterCreateInput!
  update: TwitterUpdateDataInput!
}

input TwitterWhereInput {
  AND: [TwitterWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  followers: Int
  followers_gt: Int
  followers_gte: Int
  followers_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_not: Int
  followers_not_in: [Int!]
  handle: String
  handle_contains: String
  handle_ends_with: String
  handle_gt: String
  handle_gte: String
  handle_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_not: String
  handle_not_contains: String
  handle_not_ends_with: String
  handle_not_in: [String!]
  handle_not_starts_with: String
  handle_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  link: String
  link_contains: String
  link_ends_with: String
  link_gt: String
  link_gte: String
  link_in: [String!]
  link_lt: String
  link_lte: String
  link_not: String
  link_not_contains: String
  link_not_ends_with: String
  link_not_in: [String!]
  link_not_starts_with: String
  link_starts_with: String
  NOT: [TwitterWhereInput!]
  OR: [TwitterWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input TwitterWhereUniqueInput {
  id: ID
}

type Youtube {
  analytics: Json
  createdAt: DateTime!
  followers: Int
  handle: String
  id: ID!
  link: String
  updatedAt: DateTime!
}

type YoutubeConnection {
  aggregate: AggregateYoutube!
  edges: [YoutubeEdge!]!
  pageInfo: PageInfo!
}

input YoutubeCreateInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input YoutubeCreateOneInput {
  connect: YoutubeWhereUniqueInput
  create: YoutubeCreateInput
}

type YoutubeEdge {
  cursor: String!
  node: Youtube!
}

enum YoutubeOrderByInput {
  analytics_ASC
  analytics_DESC
  createdAt_ASC
  createdAt_DESC
  followers_ASC
  followers_DESC
  handle_ASC
  handle_DESC
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input YoutubeUpdateDataInput {
  analytics: Json
  followers: Int
  handle: String
  link: String
}

input YoutubeUpdateOneInput {
  connect: YoutubeWhereUniqueInput
  create: YoutubeCreateInput
  delete: Boolean
  disconnect: Boolean
  update: YoutubeUpdateDataInput
  upsert: YoutubeUpsertNestedInput
}

input YoutubeUpsertNestedInput {
  create: YoutubeCreateInput!
  update: YoutubeUpdateDataInput!
}

input YoutubeWhereInput {
  AND: [YoutubeWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  followers: Int
  followers_gt: Int
  followers_gte: Int
  followers_in: [Int!]
  followers_lt: Int
  followers_lte: Int
  followers_not: Int
  followers_not_in: [Int!]
  handle: String
  handle_contains: String
  handle_ends_with: String
  handle_gt: String
  handle_gte: String
  handle_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_not: String
  handle_not_contains: String
  handle_not_ends_with: String
  handle_not_in: [String!]
  handle_not_starts_with: String
  handle_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  link: String
  link_contains: String
  link_ends_with: String
  link_gt: String
  link_gte: String
  link_in: [String!]
  link_lt: String
  link_lte: String
  link_not: String
  link_not_contains: String
  link_not_ends_with: String
  link_not_in: [String!]
  link_not_starts_with: String
  link_starts_with: String
  NOT: [YoutubeWhereInput!]
  OR: [YoutubeWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input YoutubeWhereUniqueInput {
  id: ID
}
